<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - lib/dpif-provider.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">lib</a> - dpif-provider.h<span style="font-size: 80%;"> (source / <a href="dpif-provider.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-09-14 01:02:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryLo">50.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : /*</a>
<span class="lineNum">       2 </span>                :            :  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
<span class="lineNum">       3 </span>                :            :  *
<span class="lineNum">       4 </span>                :            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       5 </span>                :            :  * you may not use this file except in compliance with the License.
<span class="lineNum">       6 </span>                :            :  * You may obtain a copy of the License at:
<span class="lineNum">       7 </span>                :            :  *
<span class="lineNum">       8 </span>                :            :  *     http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">       9 </span>                :            :  *
<span class="lineNum">      10 </span>                :            :  * Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      11 </span>                :            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      12 </span>                :            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      13 </span>                :            :  * See the License for the specific language governing permissions and
<span class="lineNum">      14 </span>                :            :  * limitations under the License.
<span class="lineNum">      15 </span>                :            :  */
<span class="lineNum">      16 </span>                :            : 
<span class="lineNum">      17 </span>                :            : #ifndef DPIF_PROVIDER_H
<span class="lineNum">      18 </span>                :            : #define DPIF_PROVIDER_H 1
<span class="lineNum">      19 </span>                :            : 
<span class="lineNum">      20 </span>                :            : /* Provider interface to dpifs, which provide an interface to an Open vSwitch
<span class="lineNum">      21 </span>                :            :  * datapath.  A datapath is a collection of physical or virtual ports that are
<span class="lineNum">      22 </span>                :            :  * exposed over OpenFlow as a single switch.  Datapaths and the collections of
<span class="lineNum">      23 </span>                :            :  * ports that they contain may be fixed or dynamic. */
<span class="lineNum">      24 </span>                :            : 
<span class="lineNum">      25 </span>                :            : #include &quot;openflow/openflow.h&quot;
<span class="lineNum">      26 </span>                :            : #include &quot;dpif.h&quot;
<span class="lineNum">      27 </span>                :            : #include &quot;util.h&quot;
<span class="lineNum">      28 </span>                :            : 
<span class="lineNum">      29 </span>                :            : #ifdef  __cplusplus
<span class="lineNum">      30 </span>                :            : extern &quot;C&quot; {
<span class="lineNum">      31 </span>                :            : #endif
<span class="lineNum">      32 </span>                :            : 
<span class="lineNum">      33 </span>                :            : /* Open vSwitch datapath interface.
<span class="lineNum">      34 </span>                :            :  *
<span class="lineNum">      35 </span>                :            :  * This structure should be treated as opaque by dpif implementations. */
<span class="lineNum">      36 </span>                :            : struct dpif {
<span class="lineNum">      37 </span>                :            :     const struct dpif_class *dpif_class;
<span class="lineNum">      38 </span>                :            :     char *base_name;
<span class="lineNum">      39 </span>                :            :     char *full_name;
<span class="lineNum">      40 </span>                :            :     uint8_t netflow_engine_type;
<span class="lineNum">      41 </span>                :            :     uint8_t netflow_engine_id;
<span class="lineNum">      42 </span>                :            : };
<span class="lineNum">      43 </span>                :            : 
<span class="lineNum">      44 </span>                :            : void dpif_init(struct dpif *, const struct dpif_class *, const char *name,
<span class="lineNum">      45 </span>                :            :                uint8_t netflow_engine_type, uint8_t netflow_engine_id);
<a name="46"><span class="lineNum">      46 </span>                :            : void dpif_uninit(struct dpif *dpif, bool close);</a>
<span class="lineNum">      47 </span>                :            : 
<span class="lineNum">      48 </span>                :<span class="lineCov">      39865 : static inline void dpif_assert_class(const struct dpif *dpif,</span>
<span class="lineNum">      49 </span>                :            :                                      const struct dpif_class *dpif_class)
<span class="lineNum">      50 </span>                :            : {
<span class="lineNum">      51 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 39865 times"> + </span>]:<span class="lineCov">      39865 :     ovs_assert(dpif-&gt;dpif_class == dpif_class);</span>
<span class="lineNum">      52 </span>                :<span class="lineCov">      39865 : }</span>
<span class="lineNum">      53 </span>                :            : 
<span class="lineNum">      54 </span>                :            : struct dpif_flow_dump {
<span class="lineNum">      55 </span>                :            :     struct dpif *dpif;
<span class="lineNum">      56 </span>                :            :     bool terse;         /* If true, key/mask/actions may be omitted. */
<span class="lineNum">      57 </span>                :            : };
<a name="58"><span class="lineNum">      58 </span>                :            : </a>
<span class="lineNum">      59 </span>                :            : static inline void
<span class="lineNum">      60 </span>                :<span class="lineCov">      28196 : dpif_flow_dump_init(struct dpif_flow_dump *dump, const struct dpif *dpif)</span>
<span class="lineNum">      61 </span>                :            : {
<span class="lineNum">      62 </span>                :<span class="lineCov">      28196 :     dump-&gt;dpif = CONST_CAST(struct dpif *, dpif);</span>
<span class="lineNum">      63 </span>                :<span class="lineCov">      28196 : }</span>
<span class="lineNum">      64 </span>                :            : 
<span class="lineNum">      65 </span>                :            : struct dpif_flow_dump_thread {
<span class="lineNum">      66 </span>                :            :     struct dpif *dpif;
<span class="lineNum">      67 </span>                :            : };
<a name="68"><span class="lineNum">      68 </span>                :            : </a>
<span class="lineNum">      69 </span>                :            : static inline void
<span class="lineNum">      70 </span>                :<span class="lineCov">      28199 : dpif_flow_dump_thread_init(struct dpif_flow_dump_thread *thread,</span>
<span class="lineNum">      71 </span>                :            :                            struct dpif_flow_dump *dump)
<span class="lineNum">      72 </span>                :            : {
<span class="lineNum">      73 </span>                :<span class="lineCov">      28199 :     thread-&gt;dpif = dump-&gt;dpif;</span>
<span class="lineNum">      74 </span>                :<span class="lineCov">      28199 : }</span>
<span class="lineNum">      75 </span>                :            : 
<span class="lineNum">      76 </span>                :            : struct ct_dpif_dump_state;
<span class="lineNum">      77 </span>                :            : struct ct_dpif_entry;
<span class="lineNum">      78 </span>                :            : 
<span class="lineNum">      79 </span>                :            : /* Datapath interface class structure, to be defined by each implementation of
<span class="lineNum">      80 </span>                :            :  * a datapath interface.
<span class="lineNum">      81 </span>                :            :  *
<span class="lineNum">      82 </span>                :            :  * These functions return 0 if successful or a positive errno value on failure,
<span class="lineNum">      83 </span>                :            :  * except where otherwise noted.
<span class="lineNum">      84 </span>                :            :  *
<span class="lineNum">      85 </span>                :            :  * These functions are expected to execute synchronously, that is, to block as
<span class="lineNum">      86 </span>                :            :  * necessary to obtain a result.  Thus, they may not return EAGAIN or
<span class="lineNum">      87 </span>                :            :  * EWOULDBLOCK or EINPROGRESS.  We may relax this requirement in the future if
<span class="lineNum">      88 </span>                :            :  * and when we encounter performance problems. */
<span class="lineNum">      89 </span>                :            : struct dpif_class {
<span class="lineNum">      90 </span>                :            :     /* Type of dpif in this class, e.g. &quot;system&quot;, &quot;netdev&quot;, etc.
<span class="lineNum">      91 </span>                :            :      *
<span class="lineNum">      92 </span>                :            :      * One of the providers should supply a &quot;system&quot; type, since this is
<span class="lineNum">      93 </span>                :            :      * the type assumed if no type is specified when opening a dpif. */
<span class="lineNum">      94 </span>                :            :     const char *type;
<span class="lineNum">      95 </span>                :            : 
<span class="lineNum">      96 </span>                :            :     /* Called when the dpif provider is registered, typically at program
<span class="lineNum">      97 </span>                :            :      * startup.  Returning an error from this function will prevent any
<span class="lineNum">      98 </span>                :            :      * datapath with this class from being created.
<span class="lineNum">      99 </span>                :            :      *
<span class="lineNum">     100 </span>                :            :      * This function may be set to null if a datapath class needs no
<span class="lineNum">     101 </span>                :            :      * initialization at registration time. */
<span class="lineNum">     102 </span>                :            :     int (*init)(void);
<span class="lineNum">     103 </span>                :            : 
<span class="lineNum">     104 </span>                :            :     /* Enumerates the names of all known created datapaths (of class
<span class="lineNum">     105 </span>                :            :      * 'dpif_class'), if possible, into 'all_dps'.  The caller has already
<span class="lineNum">     106 </span>                :            :      * initialized 'all_dps' and other dpif classes might already have added
<span class="lineNum">     107 </span>                :            :      * names to it.
<span class="lineNum">     108 </span>                :            :      *
<span class="lineNum">     109 </span>                :            :      * This is used by the vswitch at startup, so that it can delete any
<span class="lineNum">     110 </span>                :            :      * datapaths that are not configured.
<span class="lineNum">     111 </span>                :            :      *
<span class="lineNum">     112 </span>                :            :      * Some kinds of datapaths might not be practically enumerable, in which
<span class="lineNum">     113 </span>                :            :      * case this function may be a null pointer. */
<span class="lineNum">     114 </span>                :            :     int (*enumerate)(struct sset *all_dps, const struct dpif_class *dpif_class);
<span class="lineNum">     115 </span>                :            : 
<span class="lineNum">     116 </span>                :            :     /* Returns the type to pass to netdev_open() when a dpif of class
<span class="lineNum">     117 </span>                :            :      * 'dpif_class' has a port of type 'type', for a few special cases
<span class="lineNum">     118 </span>                :            :      * when a netdev type differs from a port type.  For example, when
<span class="lineNum">     119 </span>                :            :      * using the userspace datapath, a port of type &quot;internal&quot; needs to
<span class="lineNum">     120 </span>                :            :      * be opened as &quot;tap&quot;.
<span class="lineNum">     121 </span>                :            :      *
<span class="lineNum">     122 </span>                :            :      * Returns either 'type' itself or a string literal, which must not
<span class="lineNum">     123 </span>                :            :      * be freed. */
<span class="lineNum">     124 </span>                :            :     const char *(*port_open_type)(const struct dpif_class *dpif_class,
<span class="lineNum">     125 </span>                :            :                                   const char *type);
<span class="lineNum">     126 </span>                :            : 
<span class="lineNum">     127 </span>                :            :     /* Attempts to open an existing dpif called 'name', if 'create' is false,
<span class="lineNum">     128 </span>                :            :      * or to open an existing dpif or create a new one, if 'create' is true.
<span class="lineNum">     129 </span>                :            :      *
<span class="lineNum">     130 </span>                :            :      * 'dpif_class' is the class of dpif to open.
<span class="lineNum">     131 </span>                :            :      *
<span class="lineNum">     132 </span>                :            :      * If successful, stores a pointer to the new dpif in '*dpifp', which must
<span class="lineNum">     133 </span>                :            :      * have class 'dpif_class'.  On failure there are no requirements on what
<span class="lineNum">     134 </span>                :            :      * is stored in '*dpifp'. */
<span class="lineNum">     135 </span>                :            :     int (*open)(const struct dpif_class *dpif_class,
<span class="lineNum">     136 </span>                :            :                 const char *name, bool create, struct dpif **dpifp);
<span class="lineNum">     137 </span>                :            : 
<span class="lineNum">     138 </span>                :            :     /* Closes 'dpif' and frees associated memory. */
<span class="lineNum">     139 </span>                :            :     void (*close)(struct dpif *dpif);
<span class="lineNum">     140 </span>                :            : 
<span class="lineNum">     141 </span>                :            :     /* Attempts to destroy the dpif underlying 'dpif'.
<span class="lineNum">     142 </span>                :            :      *
<span class="lineNum">     143 </span>                :            :      * If successful, 'dpif' will not be used again except as an argument for
<span class="lineNum">     144 </span>                :            :      * the 'close' member function. */
<span class="lineNum">     145 </span>                :            :     int (*destroy)(struct dpif *dpif);
<span class="lineNum">     146 </span>                :            : 
<span class="lineNum">     147 </span>                :            :     /* Performs periodic work needed by 'dpif', if any is necessary.
<span class="lineNum">     148 </span>                :            :      * Returns true if need to revalidate. */
<span class="lineNum">     149 </span>                :            :     bool (*run)(struct dpif *dpif);
<span class="lineNum">     150 </span>                :            : 
<span class="lineNum">     151 </span>                :            :     /* Arranges for poll_block() to wake up if the &quot;run&quot; member function needs
<span class="lineNum">     152 </span>                :            :      * to be called for 'dpif'. */
<span class="lineNum">     153 </span>                :            :     void (*wait)(struct dpif *dpif);
<span class="lineNum">     154 </span>                :            : 
<span class="lineNum">     155 </span>                :            :     /* Retrieves statistics for 'dpif' into 'stats'. */
<span class="lineNum">     156 </span>                :            :     int (*get_stats)(const struct dpif *dpif, struct dpif_dp_stats *stats);
<span class="lineNum">     157 </span>                :            : 
<span class="lineNum">     158 </span>                :            :     /* Adds 'netdev' as a new port in 'dpif'.  If '*port_no' is not
<span class="lineNum">     159 </span>                :            :      * UINT32_MAX, attempts to use that as the port's port number.
<span class="lineNum">     160 </span>                :            :      *
<span class="lineNum">     161 </span>                :            :      * If port is successfully added, sets '*port_no' to the new port's
<span class="lineNum">     162 </span>                :            :      * port number.  Returns EBUSY if caller attempted to choose a port
<span class="lineNum">     163 </span>                :            :      * number, and it was in use. */
<span class="lineNum">     164 </span>                :            :     int (*port_add)(struct dpif *dpif, struct netdev *netdev,
<span class="lineNum">     165 </span>                :            :                     odp_port_t *port_no);
<span class="lineNum">     166 </span>                :            : 
<span class="lineNum">     167 </span>                :            :     /* Removes port numbered 'port_no' from 'dpif'. */
<span class="lineNum">     168 </span>                :            :     int (*port_del)(struct dpif *dpif, odp_port_t port_no);
<span class="lineNum">     169 </span>                :            : 
<span class="lineNum">     170 </span>                :            :     /* Refreshes configuration of 'dpif's port. The implementation might
<span class="lineNum">     171 </span>                :            :      * postpone applying the changes until run() is called. */
<span class="lineNum">     172 </span>                :            :     int (*port_set_config)(struct dpif *dpif, odp_port_t port_no,
<span class="lineNum">     173 </span>                :            :                            const struct smap *cfg);
<span class="lineNum">     174 </span>                :            : 
<span class="lineNum">     175 </span>                :            :     /* Queries 'dpif' for a port with the given 'port_no' or 'devname'.
<span class="lineNum">     176 </span>                :            :      * If 'port' is not null, stores information about the port into
<span class="lineNum">     177 </span>                :            :      * '*port' if successful.
<span class="lineNum">     178 </span>                :            :      *
<span class="lineNum">     179 </span>                :            :      * If 'port' is not null, the caller takes ownership of data in
<span class="lineNum">     180 </span>                :            :      * 'port' and must free it with dpif_port_destroy() when it is no
<span class="lineNum">     181 </span>                :            :      * longer needed. */
<span class="lineNum">     182 </span>                :            :     int (*port_query_by_number)(const struct dpif *dpif, odp_port_t port_no,
<span class="lineNum">     183 </span>                :            :                                 struct dpif_port *port);
<span class="lineNum">     184 </span>                :            :     int (*port_query_by_name)(const struct dpif *dpif, const char *devname,
<span class="lineNum">     185 </span>                :            :                               struct dpif_port *port);
<span class="lineNum">     186 </span>                :            : 
<span class="lineNum">     187 </span>                :            :     /* Returns the Netlink PID value to supply in OVS_ACTION_ATTR_USERSPACE
<span class="lineNum">     188 </span>                :            :      * actions as the OVS_USERSPACE_ATTR_PID attribute's value, for use in
<span class="lineNum">     189 </span>                :            :      * flows whose packets arrived on port 'port_no'.  In the case where the
<span class="lineNum">     190 </span>                :            :      * provider allocates multiple Netlink PIDs to a single port, it may use
<span class="lineNum">     191 </span>                :            :      * 'hash' to spread load among them.  The caller need not use a particular
<span class="lineNum">     192 </span>                :            :      * hash function; a 5-tuple hash is suitable.
<span class="lineNum">     193 </span>                :            :      *
<span class="lineNum">     194 </span>                :            :      * (The datapath implementation might use some different hash function for
<span class="lineNum">     195 </span>                :            :      * distributing packets received via flow misses among PIDs.  This means
<span class="lineNum">     196 </span>                :            :      * that packets received via flow misses might be reordered relative to
<span class="lineNum">     197 </span>                :            :      * packets received via userspace actions.  This is not ordinarily a
<span class="lineNum">     198 </span>                :            :      * problem.)
<span class="lineNum">     199 </span>                :            :      *
<span class="lineNum">     200 </span>                :            :      * A 'port_no' of UINT32_MAX should be treated as a special case.  The
<span class="lineNum">     201 </span>                :            :      * implementation should return a reserved PID, not allocated to any port,
<span class="lineNum">     202 </span>                :            :      * that the client may use for special purposes.
<span class="lineNum">     203 </span>                :            :      *
<span class="lineNum">     204 </span>                :            :      * The return value only needs to be meaningful when DPIF_UC_ACTION has
<span class="lineNum">     205 </span>                :            :      * been enabled in the 'dpif''s listen mask, and it is allowed to change
<span class="lineNum">     206 </span>                :            :      * when DPIF_UC_ACTION is disabled and then re-enabled.
<span class="lineNum">     207 </span>                :            :      *
<span class="lineNum">     208 </span>                :            :      * A dpif provider that doesn't have meaningful Netlink PIDs can use NULL
<span class="lineNum">     209 </span>                :            :      * for this function.  This is equivalent to always returning 0. */
<span class="lineNum">     210 </span>                :            :     uint32_t (*port_get_pid)(const struct dpif *dpif, odp_port_t port_no,
<span class="lineNum">     211 </span>                :            :                              uint32_t hash);
<span class="lineNum">     212 </span>                :            : 
<span class="lineNum">     213 </span>                :            :     /* Attempts to begin dumping the ports in a dpif.  On success, returns 0
<span class="lineNum">     214 </span>                :            :      * and initializes '*statep' with any data needed for iteration.  On
<span class="lineNum">     215 </span>                :            :      * failure, returns a positive errno value. */
<span class="lineNum">     216 </span>                :            :     int (*port_dump_start)(const struct dpif *dpif, void **statep);
<span class="lineNum">     217 </span>                :            : 
<span class="lineNum">     218 </span>                :            :     /* Attempts to retrieve another port from 'dpif' for 'state', which was
<span class="lineNum">     219 </span>                :            :      * initialized by a successful call to the 'port_dump_start' function for
<span class="lineNum">     220 </span>                :            :      * 'dpif'.  On success, stores a new dpif_port into 'port' and returns 0.
<span class="lineNum">     221 </span>                :            :      * Returns EOF if the end of the port table has been reached, or a positive
<span class="lineNum">     222 </span>                :            :      * errno value on error.  This function will not be called again once it
<span class="lineNum">     223 </span>                :            :      * returns nonzero once for a given iteration (but the 'port_dump_done'
<span class="lineNum">     224 </span>                :            :      * function will be called afterward).
<span class="lineNum">     225 </span>                :            :      *
<span class="lineNum">     226 </span>                :            :      * The dpif provider retains ownership of the data stored in 'port'.  It
<span class="lineNum">     227 </span>                :            :      * must remain valid until at least the next call to 'port_dump_next' or
<span class="lineNum">     228 </span>                :            :      * 'port_dump_done' for 'state'. */
<span class="lineNum">     229 </span>                :            :     int (*port_dump_next)(const struct dpif *dpif, void *state,
<span class="lineNum">     230 </span>                :            :                           struct dpif_port *port);
<span class="lineNum">     231 </span>                :            : 
<span class="lineNum">     232 </span>                :            :     /* Releases resources from 'dpif' for 'state', which was initialized by a
<span class="lineNum">     233 </span>                :            :      * successful call to the 'port_dump_start' function for 'dpif'.  */
<span class="lineNum">     234 </span>                :            :     int (*port_dump_done)(const struct dpif *dpif, void *state);
<span class="lineNum">     235 </span>                :            : 
<span class="lineNum">     236 </span>                :            :     /* Polls for changes in the set of ports in 'dpif'.  If the set of ports in
<span class="lineNum">     237 </span>                :            :      * 'dpif' has changed, then this function should do one of the
<span class="lineNum">     238 </span>                :            :      * following:
<span class="lineNum">     239 </span>                :            :      *
<span class="lineNum">     240 </span>                :            :      * - Preferably: store the name of the device that was added to or deleted
<span class="lineNum">     241 </span>                :            :      *   from 'dpif' in '*devnamep' and return 0.  The caller is responsible
<span class="lineNum">     242 </span>                :            :      *   for freeing '*devnamep' (with free()) when it no longer needs it.
<span class="lineNum">     243 </span>                :            :      *
<span class="lineNum">     244 </span>                :            :      * - Alternatively: return ENOBUFS, without indicating the device that was
<span class="lineNum">     245 </span>                :            :      *   added or deleted.
<span class="lineNum">     246 </span>                :            :      *
<span class="lineNum">     247 </span>                :            :      * Occasional 'false positives', in which the function returns 0 while
<span class="lineNum">     248 </span>                :            :      * indicating a device that was not actually added or deleted or returns
<span class="lineNum">     249 </span>                :            :      * ENOBUFS without any change, are acceptable.
<span class="lineNum">     250 </span>                :            :      *
<span class="lineNum">     251 </span>                :            :      * If the set of ports in 'dpif' has not changed, returns EAGAIN.  May also
<span class="lineNum">     252 </span>                :            :      * return other positive errno values to indicate that something has gone
<span class="lineNum">     253 </span>                :            :      * wrong. */
<span class="lineNum">     254 </span>                :            :     int (*port_poll)(const struct dpif *dpif, char **devnamep);
<span class="lineNum">     255 </span>                :            : 
<span class="lineNum">     256 </span>                :            :     /* Arranges for the poll loop to wake up when 'port_poll' will return a
<span class="lineNum">     257 </span>                :            :      * value other than EAGAIN. */
<span class="lineNum">     258 </span>                :            :     void (*port_poll_wait)(const struct dpif *dpif);
<span class="lineNum">     259 </span>                :            : 
<span class="lineNum">     260 </span>                :            :     /* Deletes all flows from 'dpif' and clears all of its queues of received
<span class="lineNum">     261 </span>                :            :      * packets. */
<span class="lineNum">     262 </span>                :            :     int (*flow_flush)(struct dpif *dpif);
<span class="lineNum">     263 </span>                :            : 
<span class="lineNum">     264 </span>                :            :     /* Flow dumping interface.
<span class="lineNum">     265 </span>                :            :      *
<span class="lineNum">     266 </span>                :            :      * This is the back-end for the flow dumping interface described in
<span class="lineNum">     267 </span>                :            :      * dpif.h.  Please read the comments there first, because this code
<span class="lineNum">     268 </span>                :            :      * closely follows it.
<span class="lineNum">     269 </span>                :            :      *
<span class="lineNum">     270 </span>                :            :      * 'flow_dump_create' and 'flow_dump_thread_create' must always return an
<span class="lineNum">     271 </span>                :            :      * initialized and usable data structure and defer error return until
<span class="lineNum">     272 </span>                :            :      * flow_dump_destroy().  This hasn't been a problem for the dpifs that
<span class="lineNum">     273 </span>                :            :      * exist so far.
<span class="lineNum">     274 </span>                :            :      *
<span class="lineNum">     275 </span>                :            :      * 'flow_dump_create' and 'flow_dump_thread_create' must initialize the
<span class="lineNum">     276 </span>                :            :      * structures that they return with dpif_flow_dump_init() and
<span class="lineNum">     277 </span>                :            :      * dpif_flow_dump_thread_init(), respectively.
<span class="lineNum">     278 </span>                :            :      *
<span class="lineNum">     279 </span>                :            :      * If 'terse' is true, then only UID and statistics will
<span class="lineNum">     280 </span>                :            :      * be returned in the dump. Otherwise, all fields will be returned. */
<span class="lineNum">     281 </span>                :            :     struct dpif_flow_dump *(*flow_dump_create)(const struct dpif *dpif,
<span class="lineNum">     282 </span>                :            :                                                bool terse);
<span class="lineNum">     283 </span>                :            :     int (*flow_dump_destroy)(struct dpif_flow_dump *dump);
<span class="lineNum">     284 </span>                :            : 
<span class="lineNum">     285 </span>                :            :     struct dpif_flow_dump_thread *(*flow_dump_thread_create)(
<span class="lineNum">     286 </span>                :            :         struct dpif_flow_dump *dump);
<span class="lineNum">     287 </span>                :            :     void (*flow_dump_thread_destroy)(struct dpif_flow_dump_thread *thread);
<span class="lineNum">     288 </span>                :            : 
<span class="lineNum">     289 </span>                :            :     int (*flow_dump_next)(struct dpif_flow_dump_thread *thread,
<span class="lineNum">     290 </span>                :            :                           struct dpif_flow *flows, int max_flows);
<span class="lineNum">     291 </span>                :            : 
<span class="lineNum">     292 </span>                :            :     /* Executes each of the 'n_ops' operations in 'ops' on 'dpif', in the order
<span class="lineNum">     293 </span>                :            :      * in which they are specified, placing each operation's results in the
<span class="lineNum">     294 </span>                :            :      * &quot;output&quot; members documented in comments and the 'error' member of each
<span class="lineNum">     295 </span>                :            :      * dpif_op. */
<span class="lineNum">     296 </span>                :            :     void (*operate)(struct dpif *dpif, struct dpif_op **ops, size_t n_ops);
<span class="lineNum">     297 </span>                :            : 
<span class="lineNum">     298 </span>                :            :     /* Enables or disables receiving packets with dpif_recv() for 'dpif'.
<span class="lineNum">     299 </span>                :            :      * Turning packet receive off and then back on is allowed to change Netlink
<span class="lineNum">     300 </span>                :            :      * PID assignments (see -&gt;port_get_pid()).  The client is responsible for
<span class="lineNum">     301 </span>                :            :      * updating flows as necessary if it does this. */
<span class="lineNum">     302 </span>                :            :     int (*recv_set)(struct dpif *dpif, bool enable);
<span class="lineNum">     303 </span>                :            : 
<span class="lineNum">     304 </span>                :            :     /* Refreshes the poll loops and Netlink sockets associated to each port,
<span class="lineNum">     305 </span>                :            :      * when the number of upcall handlers (upcall receiving thread) is changed
<span class="lineNum">     306 </span>                :            :      * to 'n_handlers' and receiving packets for 'dpif' is enabled by
<span class="lineNum">     307 </span>                :            :      * recv_set().
<span class="lineNum">     308 </span>                :            :      *
<span class="lineNum">     309 </span>                :            :      * Since multiple upcall handlers can read upcalls simultaneously from
<span class="lineNum">     310 </span>                :            :      * 'dpif', each port can have multiple Netlink sockets, one per upcall
<span class="lineNum">     311 </span>                :            :      * handler.  So, handlers_set() is responsible for the following tasks:
<span class="lineNum">     312 </span>                :            :      *
<span class="lineNum">     313 </span>                :            :      *    When receiving upcall is enabled, extends or creates the
<span class="lineNum">     314 </span>                :            :      *    configuration to support:
<span class="lineNum">     315 </span>                :            :      *
<span class="lineNum">     316 </span>                :            :      *        - 'n_handlers' Netlink sockets for each port.
<span class="lineNum">     317 </span>                :            :      *
<span class="lineNum">     318 </span>                :            :      *        - 'n_handlers' poll loops, one for each upcall handler.
<span class="lineNum">     319 </span>                :            :      *
<span class="lineNum">     320 </span>                :            :      *        - registering the Netlink sockets for the same upcall handler to
<span class="lineNum">     321 </span>                :            :      *          the corresponding poll loop.
<span class="lineNum">     322 </span>                :            :      * */
<span class="lineNum">     323 </span>                :            :     int (*handlers_set)(struct dpif *dpif, uint32_t n_handlers);
<span class="lineNum">     324 </span>                :            : 
<span class="lineNum">     325 </span>                :            :     /* If 'dpif' creates its own I/O polling threads, refreshes poll threads
<span class="lineNum">     326 </span>                :            :      * configuration.  'cmask' configures the cpu mask for setting the polling
<span class="lineNum">     327 </span>                :            :      * threads' cpu affinity.  The implementation might postpone applying the
<span class="lineNum">     328 </span>                :            :      * changes until run() is called. */
<span class="lineNum">     329 </span>                :            :     int (*poll_threads_set)(struct dpif *dpif, const char *cmask);
<span class="lineNum">     330 </span>                :            : 
<span class="lineNum">     331 </span>                :            :     /* Translates OpenFlow queue ID 'queue_id' (in host byte order) into a
<span class="lineNum">     332 </span>                :            :      * priority value used for setting packet priority. */
<span class="lineNum">     333 </span>                :            :     int (*queue_to_priority)(const struct dpif *dpif, uint32_t queue_id,
<span class="lineNum">     334 </span>                :            :                              uint32_t *priority);
<span class="lineNum">     335 </span>                :            : 
<span class="lineNum">     336 </span>                :            :     /* Polls for an upcall from 'dpif' for an upcall handler.  Since there
<span class="lineNum">     337 </span>                :            :      * can be multiple poll loops (see -&gt;handlers_set()), 'handler_id' is
<span class="lineNum">     338 </span>                :            :      * needed as index to identify the corresponding poll loop.  If
<span class="lineNum">     339 </span>                :            :      * successful, stores the upcall into '*upcall', using 'buf' for
<span class="lineNum">     340 </span>                :            :      * storage.  Should only be called if 'recv_set' has been used to enable
<span class="lineNum">     341 </span>                :            :      * receiving packets from 'dpif'.
<span class="lineNum">     342 </span>                :            :      *
<span class="lineNum">     343 </span>                :            :      * The implementation should point 'upcall-&gt;key' and 'upcall-&gt;userdata'
<span class="lineNum">     344 </span>                :            :      * (if any) into data in the caller-provided 'buf'.  The implementation may
<span class="lineNum">     345 </span>                :            :      * also use 'buf' for storing the data of 'upcall-&gt;packet'.  If necessary
<span class="lineNum">     346 </span>                :            :      * to make room, the implementation may reallocate the data in 'buf'.
<span class="lineNum">     347 </span>                :            :      *
<span class="lineNum">     348 </span>                :            :      * The caller owns the data of 'upcall-&gt;packet' and may modify it.  If
<span class="lineNum">     349 </span>                :            :      * packet's headroom is exhausted as it is manipulated, 'upcall-&gt;packet'
<span class="lineNum">     350 </span>                :            :      * will be reallocated.  This requires the data of 'upcall-&gt;packet' to be
<span class="lineNum">     351 </span>                :            :      * released with ofpbuf_uninit() before 'upcall' is destroyed.  However,
<span class="lineNum">     352 </span>                :            :      * when an error is returned, the 'upcall-&gt;packet' may be uninitialized
<span class="lineNum">     353 </span>                :            :      * and should not be released.
<span class="lineNum">     354 </span>                :            :      *
<span class="lineNum">     355 </span>                :            :      * This function must not block.  If no upcall is pending when it is
<span class="lineNum">     356 </span>                :            :      * called, it should return EAGAIN without blocking. */
<span class="lineNum">     357 </span>                :            :     int (*recv)(struct dpif *dpif, uint32_t handler_id,
<span class="lineNum">     358 </span>                :            :                 struct dpif_upcall *upcall, struct ofpbuf *buf);
<span class="lineNum">     359 </span>                :            : 
<span class="lineNum">     360 </span>                :            :     /* Arranges for the poll loop for an upcall handler to wake up when 'dpif'
<span class="lineNum">     361 </span>                :            :      * has a message queued to be received with the recv member functions.
<span class="lineNum">     362 </span>                :            :      * Since there can be multiple poll loops (see -&gt;handlers_set()),
<span class="lineNum">     363 </span>                :            :      * 'handler_id' is needed as index to identify the corresponding poll loop.
<span class="lineNum">     364 </span>                :            :      * */
<span class="lineNum">     365 </span>                :            :     void (*recv_wait)(struct dpif *dpif, uint32_t handler_id);
<span class="lineNum">     366 </span>                :            : 
<span class="lineNum">     367 </span>                :            :     /* Throws away any queued upcalls that 'dpif' currently has ready to
<span class="lineNum">     368 </span>                :            :      * return. */
<span class="lineNum">     369 </span>                :            :     void (*recv_purge)(struct dpif *dpif);
<span class="lineNum">     370 </span>                :            : 
<span class="lineNum">     371 </span>                :            :     /* When 'dpif' is about to purge the datapath, the higher layer may want
<span class="lineNum">     372 </span>                :            :      * to be notified so that it could try reacting accordingly (e.g. grabbing
<span class="lineNum">     373 </span>                :            :      * all flow stats before they are gone).
<span class="lineNum">     374 </span>                :            :      *
<span class="lineNum">     375 </span>                :            :      * Registers an upcall callback function with 'dpif'.  This is only used
<span class="lineNum">     376 </span>                :            :      * if 'dpif' needs to notify the purging of datapath.  'aux' is passed to
<span class="lineNum">     377 </span>                :            :      * the callback on invocation. */
<span class="lineNum">     378 </span>                :            :     void (*register_dp_purge_cb)(struct dpif *, dp_purge_callback *, void *aux);
<span class="lineNum">     379 </span>                :            : 
<span class="lineNum">     380 </span>                :            :     /* For datapaths that run in userspace (i.e. dpif-netdev), threads polling
<span class="lineNum">     381 </span>                :            :      * for incoming packets can directly call upcall functions instead of
<span class="lineNum">     382 </span>                :            :      * offloading packet processing to separate handler threads. Datapaths
<span class="lineNum">     383 </span>                :            :      * that directly call upcall functions should use the functions below to
<span class="lineNum">     384 </span>                :            :      * to register an upcall function and enable / disable upcalls.
<span class="lineNum">     385 </span>                :            :      *
<span class="lineNum">     386 </span>                :            :      * Registers an upcall callback function with 'dpif'. This is only used
<span class="lineNum">     387 </span>                :            :      * if 'dpif' directly executes upcall functions. 'aux' is passed to the
<span class="lineNum">     388 </span>                :            :      * callback on invocation. */
<span class="lineNum">     389 </span>                :            :     void (*register_upcall_cb)(struct dpif *, upcall_callback *, void *aux);
<span class="lineNum">     390 </span>                :            : 
<span class="lineNum">     391 </span>                :            :     /* Enables upcalls if 'dpif' directly executes upcall functions. */
<span class="lineNum">     392 </span>                :            :     void (*enable_upcall)(struct dpif *);
<span class="lineNum">     393 </span>                :            : 
<span class="lineNum">     394 </span>                :            :     /* Disables upcalls if 'dpif' directly executes upcall functions. */
<span class="lineNum">     395 </span>                :            :     void (*disable_upcall)(struct dpif *);
<span class="lineNum">     396 </span>                :            : 
<span class="lineNum">     397 </span>                :            :     /* Get datapath version. Caller is responsible for freeing the string
<span class="lineNum">     398 </span>                :            :      * returned.  */
<span class="lineNum">     399 </span>                :            :     char *(*get_datapath_version)(void);
<span class="lineNum">     400 </span>                :            : 
<span class="lineNum">     401 </span>                :            :     /* Conntrack entry dumping interface.
<span class="lineNum">     402 </span>                :            :      *
<span class="lineNum">     403 </span>                :            :      * These functions are used by ct-dpif.c to provide a datapath-agnostic
<span class="lineNum">     404 </span>                :            :      * dumping interface to the connection trackes provided by the
<span class="lineNum">     405 </span>                :            :      * datapaths.
<span class="lineNum">     406 </span>                :            :      *
<span class="lineNum">     407 </span>                :            :      * ct_dump_start() should put in '*state' a pointer to a newly allocated
<span class="lineNum">     408 </span>                :            :      * stucture that will be passed by the caller to ct_dump_next() and
<span class="lineNum">     409 </span>                :            :      * ct_dump_done(). If 'zone' is not NULL, only the entries in '*zone'
<span class="lineNum">     410 </span>                :            :      * should be dumped.
<span class="lineNum">     411 </span>                :            :      *
<span class="lineNum">     412 </span>                :            :      * ct_dump_next() should fill 'entry' with information from a connection
<span class="lineNum">     413 </span>                :            :      * and prepare to dump the next one on a subsequest invocation.
<span class="lineNum">     414 </span>                :            :      *
<span class="lineNum">     415 </span>                :            :      * ct_dump_done should perform any cleanup necessary (including
<span class="lineNum">     416 </span>                :            :      * deallocating the 'state' structure, if applicable). */
<span class="lineNum">     417 </span>                :            :     int (*ct_dump_start)(struct dpif *, struct ct_dpif_dump_state **state,
<span class="lineNum">     418 </span>                :            :                          const uint16_t *zone);
<span class="lineNum">     419 </span>                :            :     int (*ct_dump_next)(struct dpif *, struct ct_dpif_dump_state *,
<span class="lineNum">     420 </span>                :            :                         struct ct_dpif_entry *entry);
<span class="lineNum">     421 </span>                :            :     int (*ct_dump_done)(struct dpif *, struct ct_dpif_dump_state *state);
<span class="lineNum">     422 </span>                :            : 
<span class="lineNum">     423 </span>                :            :     /* Flushes the connection tracking tables. If 'zone' is not NULL,
<span class="lineNum">     424 </span>                :            :      * only deletes connections in '*zone'. */
<span class="lineNum">     425 </span>                :            :     int (*ct_flush)(struct dpif *, const uint16_t *zone);
<span class="lineNum">     426 </span>                :            : };
<span class="lineNum">     427 </span>                :            : 
<span class="lineNum">     428 </span>                :            : extern const struct dpif_class dpif_netlink_class;
<span class="lineNum">     429 </span>                :            : extern const struct dpif_class dpif_netdev_class;
<span class="lineNum">     430 </span>                :            : 
<span class="lineNum">     431 </span>                :            : #ifdef  __cplusplus
<span class="lineNum">     432 </span>                :            : }
<span class="lineNum">     433 </span>                :            : #endif
<span class="lineNum">     434 </span>                :            : 
<span class="lineNum">     435 </span>                :            : #endif /* dpif-provider.h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
