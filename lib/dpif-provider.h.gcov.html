<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - lib/dpif-provider.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">lib</a> - dpif-provider.h<span style="font-size: 80%;"> (source / <a href="dpif-provider.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">66.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2014-07-01</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">66.7 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : /*</a>
<span class="lineNum">       2 </span>                :            :  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
<span class="lineNum">       3 </span>                :            :  *
<span class="lineNum">       4 </span>                :            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       5 </span>                :            :  * you may not use this file except in compliance with the License.
<span class="lineNum">       6 </span>                :            :  * You may obtain a copy of the License at:
<span class="lineNum">       7 </span>                :            :  *
<span class="lineNum">       8 </span>                :            :  *     http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">       9 </span>                :            :  *
<span class="lineNum">      10 </span>                :            :  * Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      11 </span>                :            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      12 </span>                :            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      13 </span>                :            :  * See the License for the specific language governing permissions and
<span class="lineNum">      14 </span>                :            :  * limitations under the License.
<span class="lineNum">      15 </span>                :            :  */
<span class="lineNum">      16 </span>                :            : 
<span class="lineNum">      17 </span>                :            : #ifndef DPIF_PROVIDER_H
<span class="lineNum">      18 </span>                :            : #define DPIF_PROVIDER_H 1
<span class="lineNum">      19 </span>                :            : 
<span class="lineNum">      20 </span>                :            : /* Provider interface to dpifs, which provide an interface to an Open vSwitch
<span class="lineNum">      21 </span>                :            :  * datapath.  A datapath is a collection of physical or virtual ports that are
<span class="lineNum">      22 </span>                :            :  * exposed over OpenFlow as a single switch.  Datapaths and the collections of
<span class="lineNum">      23 </span>                :            :  * ports that they contain may be fixed or dynamic. */
<span class="lineNum">      24 </span>                :            : 
<span class="lineNum">      25 </span>                :            : #include &quot;openflow/openflow.h&quot;
<span class="lineNum">      26 </span>                :            : #include &quot;dpif.h&quot;
<span class="lineNum">      27 </span>                :            : #include &quot;util.h&quot;
<span class="lineNum">      28 </span>                :            : 
<span class="lineNum">      29 </span>                :            : #ifdef  __cplusplus
<span class="lineNum">      30 </span>                :            : extern &quot;C&quot; {
<span class="lineNum">      31 </span>                :            : #endif
<span class="lineNum">      32 </span>                :            : 
<span class="lineNum">      33 </span>                :            : /* Open vSwitch datapath interface.
<span class="lineNum">      34 </span>                :            :  *
<span class="lineNum">      35 </span>                :            :  * This structure should be treated as opaque by dpif implementations. */
<span class="lineNum">      36 </span>                :            : struct dpif {
<span class="lineNum">      37 </span>                :            :     const struct dpif_class *dpif_class;
<span class="lineNum">      38 </span>                :            :     char *base_name;
<span class="lineNum">      39 </span>                :            :     char *full_name;
<span class="lineNum">      40 </span>                :            :     uint8_t netflow_engine_type;
<span class="lineNum">      41 </span>                :            :     uint8_t netflow_engine_id;
<span class="lineNum">      42 </span>                :            : };
<span class="lineNum">      43 </span>                :            : 
<span class="lineNum">      44 </span>                :            : void dpif_init(struct dpif *, const struct dpif_class *, const char *name,
<span class="lineNum">      45 </span>                :            :                uint8_t netflow_engine_type, uint8_t netflow_engine_id);
<a name="46"><span class="lineNum">      46 </span>                :            : void dpif_uninit(struct dpif *dpif, bool close);</a>
<span class="lineNum">      47 </span>                :            : 
<span class="lineNum">      48 </span>                :<span class="lineNoCov">          0 : static inline void dpif_assert_class(const struct dpif *dpif,</span>
<span class="lineNum">      49 </span>                :            :                                      const struct dpif_class *dpif_class)
<span class="lineNum">      50 </span>                :            : {
<span class="lineNum">      51 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :     ovs_assert(dpif-&gt;dpif_class == dpif_class);</span>
<span class="lineNum">      52 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">      53 </span>                :            : 
<span class="lineNum">      54 </span>                :            : struct dpif_flow_dump {
<span class="lineNum">      55 </span>                :            :     struct dpif *dpif;
<span class="lineNum">      56 </span>                :            : };
<a name="57"><span class="lineNum">      57 </span>                :            : </a>
<span class="lineNum">      58 </span>                :            : static inline void
<span class="lineNum">      59 </span>                :<span class="lineCov">       8165 : dpif_flow_dump_init(struct dpif_flow_dump *dump, const struct dpif *dpif)</span>
<span class="lineNum">      60 </span>                :            : {
<span class="lineNum">      61 </span>                :<span class="lineCov">       8165 :     dump-&gt;dpif = CONST_CAST(struct dpif *, dpif);</span>
<span class="lineNum">      62 </span>                :<span class="lineCov">       8165 : }</span>
<span class="lineNum">      63 </span>                :            : 
<span class="lineNum">      64 </span>                :            : struct dpif_flow_dump_thread {
<span class="lineNum">      65 </span>                :            :     struct dpif *dpif;
<span class="lineNum">      66 </span>                :            : };
<a name="67"><span class="lineNum">      67 </span>                :            : </a>
<span class="lineNum">      68 </span>                :            : static inline void
<span class="lineNum">      69 </span>                :<span class="lineCov">      16324 : dpif_flow_dump_thread_init(struct dpif_flow_dump_thread *thread,</span>
<span class="lineNum">      70 </span>                :            :                            struct dpif_flow_dump *dump)
<span class="lineNum">      71 </span>                :            : {
<span class="lineNum">      72 </span>                :<span class="lineCov">      16324 :     thread-&gt;dpif = dump-&gt;dpif;</span>
<span class="lineNum">      73 </span>                :<span class="lineCov">      16324 : }</span>
<span class="lineNum">      74 </span>                :            : 
<span class="lineNum">      75 </span>                :            : /* Datapath interface class structure, to be defined by each implementation of
<span class="lineNum">      76 </span>                :            :  * a datapath interface.
<span class="lineNum">      77 </span>                :            :  *
<span class="lineNum">      78 </span>                :            :  * These functions return 0 if successful or a positive errno value on failure,
<span class="lineNum">      79 </span>                :            :  * except where otherwise noted.
<span class="lineNum">      80 </span>                :            :  *
<span class="lineNum">      81 </span>                :            :  * These functions are expected to execute synchronously, that is, to block as
<span class="lineNum">      82 </span>                :            :  * necessary to obtain a result.  Thus, they may not return EAGAIN or
<span class="lineNum">      83 </span>                :            :  * EWOULDBLOCK or EINPROGRESS.  We may relax this requirement in the future if
<span class="lineNum">      84 </span>                :            :  * and when we encounter performance problems. */
<span class="lineNum">      85 </span>                :            : struct dpif_class {
<span class="lineNum">      86 </span>                :            :     /* Type of dpif in this class, e.g. &quot;system&quot;, &quot;netdev&quot;, etc.
<span class="lineNum">      87 </span>                :            :      *
<span class="lineNum">      88 </span>                :            :      * One of the providers should supply a &quot;system&quot; type, since this is
<span class="lineNum">      89 </span>                :            :      * the type assumed if no type is specified when opening a dpif. */
<span class="lineNum">      90 </span>                :            :     const char *type;
<span class="lineNum">      91 </span>                :            : 
<span class="lineNum">      92 </span>                :            :     /* Enumerates the names of all known created datapaths (of class
<span class="lineNum">      93 </span>                :            :      * 'dpif_class'), if possible, into 'all_dps'.  The caller has already
<span class="lineNum">      94 </span>                :            :      * initialized 'all_dps' and other dpif classes might already have added
<span class="lineNum">      95 </span>                :            :      * names to it.
<span class="lineNum">      96 </span>                :            :      *
<span class="lineNum">      97 </span>                :            :      * This is used by the vswitch at startup, so that it can delete any
<span class="lineNum">      98 </span>                :            :      * datapaths that are not configured.
<span class="lineNum">      99 </span>                :            :      *
<span class="lineNum">     100 </span>                :            :      * Some kinds of datapaths might not be practically enumerable, in which
<span class="lineNum">     101 </span>                :            :      * case this function may be a null pointer. */
<span class="lineNum">     102 </span>                :            :     int (*enumerate)(struct sset *all_dps, const struct dpif_class *dpif_class);
<span class="lineNum">     103 </span>                :            : 
<span class="lineNum">     104 </span>                :            :     /* Returns the type to pass to netdev_open() when a dpif of class
<span class="lineNum">     105 </span>                :            :      * 'dpif_class' has a port of type 'type', for a few special cases
<span class="lineNum">     106 </span>                :            :      * when a netdev type differs from a port type.  For example, when
<span class="lineNum">     107 </span>                :            :      * using the userspace datapath, a port of type &quot;internal&quot; needs to
<span class="lineNum">     108 </span>                :            :      * be opened as &quot;tap&quot;.
<span class="lineNum">     109 </span>                :            :      *
<span class="lineNum">     110 </span>                :            :      * Returns either 'type' itself or a string literal, which must not
<span class="lineNum">     111 </span>                :            :      * be freed. */
<span class="lineNum">     112 </span>                :            :     const char *(*port_open_type)(const struct dpif_class *dpif_class,
<span class="lineNum">     113 </span>                :            :                                   const char *type);
<span class="lineNum">     114 </span>                :            : 
<span class="lineNum">     115 </span>                :            :     /* Attempts to open an existing dpif called 'name', if 'create' is false,
<span class="lineNum">     116 </span>                :            :      * or to open an existing dpif or create a new one, if 'create' is true.
<span class="lineNum">     117 </span>                :            :      *
<span class="lineNum">     118 </span>                :            :      * 'dpif_class' is the class of dpif to open.
<span class="lineNum">     119 </span>                :            :      *
<span class="lineNum">     120 </span>                :            :      * If successful, stores a pointer to the new dpif in '*dpifp', which must
<span class="lineNum">     121 </span>                :            :      * have class 'dpif_class'.  On failure there are no requirements on what
<span class="lineNum">     122 </span>                :            :      * is stored in '*dpifp'. */
<span class="lineNum">     123 </span>                :            :     int (*open)(const struct dpif_class *dpif_class,
<span class="lineNum">     124 </span>                :            :                 const char *name, bool create, struct dpif **dpifp);
<span class="lineNum">     125 </span>                :            : 
<span class="lineNum">     126 </span>                :            :     /* Closes 'dpif' and frees associated memory. */
<span class="lineNum">     127 </span>                :            :     void (*close)(struct dpif *dpif);
<span class="lineNum">     128 </span>                :            : 
<span class="lineNum">     129 </span>                :            :     /* Attempts to destroy the dpif underlying 'dpif'.
<span class="lineNum">     130 </span>                :            :      *
<span class="lineNum">     131 </span>                :            :      * If successful, 'dpif' will not be used again except as an argument for
<span class="lineNum">     132 </span>                :            :      * the 'close' member function. */
<span class="lineNum">     133 </span>                :            :     int (*destroy)(struct dpif *dpif);
<span class="lineNum">     134 </span>                :            : 
<span class="lineNum">     135 </span>                :            :     /* Performs periodic work needed by 'dpif', if any is necessary. */
<span class="lineNum">     136 </span>                :            :     void (*run)(struct dpif *dpif);
<span class="lineNum">     137 </span>                :            : 
<span class="lineNum">     138 </span>                :            :     /* Arranges for poll_block() to wake up if the &quot;run&quot; member function needs
<span class="lineNum">     139 </span>                :            :      * to be called for 'dpif'. */
<span class="lineNum">     140 </span>                :            :     void (*wait)(struct dpif *dpif);
<span class="lineNum">     141 </span>                :            : 
<span class="lineNum">     142 </span>                :            :     /* Retrieves statistics for 'dpif' into 'stats'. */
<span class="lineNum">     143 </span>                :            :     int (*get_stats)(const struct dpif *dpif, struct dpif_dp_stats *stats);
<span class="lineNum">     144 </span>                :            : 
<span class="lineNum">     145 </span>                :            :     /* Adds 'netdev' as a new port in 'dpif'.  If '*port_no' is not
<span class="lineNum">     146 </span>                :            :      * UINT32_MAX, attempts to use that as the port's port number.
<span class="lineNum">     147 </span>                :            :      *
<span class="lineNum">     148 </span>                :            :      * If port is successfully added, sets '*port_no' to the new port's
<span class="lineNum">     149 </span>                :            :      * port number.  Returns EBUSY if caller attempted to choose a port
<span class="lineNum">     150 </span>                :            :      * number, and it was in use. */
<span class="lineNum">     151 </span>                :            :     int (*port_add)(struct dpif *dpif, struct netdev *netdev,
<span class="lineNum">     152 </span>                :            :                     odp_port_t *port_no);
<span class="lineNum">     153 </span>                :            : 
<span class="lineNum">     154 </span>                :            :     /* Removes port numbered 'port_no' from 'dpif'. */
<span class="lineNum">     155 </span>                :            :     int (*port_del)(struct dpif *dpif, odp_port_t port_no);
<span class="lineNum">     156 </span>                :            : 
<span class="lineNum">     157 </span>                :            :     /* Queries 'dpif' for a port with the given 'port_no' or 'devname'.
<span class="lineNum">     158 </span>                :            :      * If 'port' is not null, stores information about the port into
<span class="lineNum">     159 </span>                :            :      * '*port' if successful.
<span class="lineNum">     160 </span>                :            :      *
<span class="lineNum">     161 </span>                :            :      * If 'port' is not null, the caller takes ownership of data in
<span class="lineNum">     162 </span>                :            :      * 'port' and must free it with dpif_port_destroy() when it is no
<span class="lineNum">     163 </span>                :            :      * longer needed. */
<span class="lineNum">     164 </span>                :            :     int (*port_query_by_number)(const struct dpif *dpif, odp_port_t port_no,
<span class="lineNum">     165 </span>                :            :                                 struct dpif_port *port);
<span class="lineNum">     166 </span>                :            :     int (*port_query_by_name)(const struct dpif *dpif, const char *devname,
<span class="lineNum">     167 </span>                :            :                               struct dpif_port *port);
<span class="lineNum">     168 </span>                :            : 
<span class="lineNum">     169 </span>                :            :     /* Returns the Netlink PID value to supply in OVS_ACTION_ATTR_USERSPACE
<span class="lineNum">     170 </span>                :            :      * actions as the OVS_USERSPACE_ATTR_PID attribute's value, for use in
<span class="lineNum">     171 </span>                :            :      * flows whose packets arrived on port 'port_no'.  In the case where the
<span class="lineNum">     172 </span>                :            :      * provider allocates multiple Netlink PIDs to a single port, it may use
<span class="lineNum">     173 </span>                :            :      * 'hash' to spread load among them.  The caller need not use a particular
<span class="lineNum">     174 </span>                :            :      * hash function; a 5-tuple hash is suitable.
<span class="lineNum">     175 </span>                :            :      *
<span class="lineNum">     176 </span>                :            :      * (The datapath implementation might use some different hash function for
<span class="lineNum">     177 </span>                :            :      * distributing packets received via flow misses among PIDs.  This means
<span class="lineNum">     178 </span>                :            :      * that packets received via flow misses might be reordered relative to
<span class="lineNum">     179 </span>                :            :      * packets received via userspace actions.  This is not ordinarily a
<span class="lineNum">     180 </span>                :            :      * problem.)
<span class="lineNum">     181 </span>                :            :      *
<span class="lineNum">     182 </span>                :            :      * A 'port_no' of UINT32_MAX should be treated as a special case.  The
<span class="lineNum">     183 </span>                :            :      * implementation should return a reserved PID, not allocated to any port,
<span class="lineNum">     184 </span>                :            :      * that the client may use for special purposes.
<span class="lineNum">     185 </span>                :            :      *
<span class="lineNum">     186 </span>                :            :      * The return value only needs to be meaningful when DPIF_UC_ACTION has
<span class="lineNum">     187 </span>                :            :      * been enabled in the 'dpif''s listen mask, and it is allowed to change
<span class="lineNum">     188 </span>                :            :      * when DPIF_UC_ACTION is disabled and then re-enabled.
<span class="lineNum">     189 </span>                :            :      *
<span class="lineNum">     190 </span>                :            :      * A dpif provider that doesn't have meaningful Netlink PIDs can use NULL
<span class="lineNum">     191 </span>                :            :      * for this function.  This is equivalent to always returning 0. */
<span class="lineNum">     192 </span>                :            :     uint32_t (*port_get_pid)(const struct dpif *dpif, odp_port_t port_no,
<span class="lineNum">     193 </span>                :            :                              uint32_t hash);
<span class="lineNum">     194 </span>                :            : 
<span class="lineNum">     195 </span>                :            :     /* Attempts to begin dumping the ports in a dpif.  On success, returns 0
<span class="lineNum">     196 </span>                :            :      * and initializes '*statep' with any data needed for iteration.  On
<span class="lineNum">     197 </span>                :            :      * failure, returns a positive errno value. */
<span class="lineNum">     198 </span>                :            :     int (*port_dump_start)(const struct dpif *dpif, void **statep);
<span class="lineNum">     199 </span>                :            : 
<span class="lineNum">     200 </span>                :            :     /* Attempts to retrieve another port from 'dpif' for 'state', which was
<span class="lineNum">     201 </span>                :            :      * initialized by a successful call to the 'port_dump_start' function for
<span class="lineNum">     202 </span>                :            :      * 'dpif'.  On success, stores a new dpif_port into 'port' and returns 0.
<span class="lineNum">     203 </span>                :            :      * Returns EOF if the end of the port table has been reached, or a positive
<span class="lineNum">     204 </span>                :            :      * errno value on error.  This function will not be called again once it
<span class="lineNum">     205 </span>                :            :      * returns nonzero once for a given iteration (but the 'port_dump_done'
<span class="lineNum">     206 </span>                :            :      * function will be called afterward).
<span class="lineNum">     207 </span>                :            :      *
<span class="lineNum">     208 </span>                :            :      * The dpif provider retains ownership of the data stored in 'port'.  It
<span class="lineNum">     209 </span>                :            :      * must remain valid until at least the next call to 'port_dump_next' or
<span class="lineNum">     210 </span>                :            :      * 'port_dump_done' for 'state'. */
<span class="lineNum">     211 </span>                :            :     int (*port_dump_next)(const struct dpif *dpif, void *state,
<span class="lineNum">     212 </span>                :            :                           struct dpif_port *port);
<span class="lineNum">     213 </span>                :            : 
<span class="lineNum">     214 </span>                :            :     /* Releases resources from 'dpif' for 'state', which was initialized by a
<span class="lineNum">     215 </span>                :            :      * successful call to the 'port_dump_start' function for 'dpif'.  */
<span class="lineNum">     216 </span>                :            :     int (*port_dump_done)(const struct dpif *dpif, void *state);
<span class="lineNum">     217 </span>                :            : 
<span class="lineNum">     218 </span>                :            :     /* Polls for changes in the set of ports in 'dpif'.  If the set of ports in
<span class="lineNum">     219 </span>                :            :      * 'dpif' has changed, then this function should do one of the
<span class="lineNum">     220 </span>                :            :      * following:
<span class="lineNum">     221 </span>                :            :      *
<span class="lineNum">     222 </span>                :            :      * - Preferably: store the name of the device that was added to or deleted
<span class="lineNum">     223 </span>                :            :      *   from 'dpif' in '*devnamep' and return 0.  The caller is responsible
<span class="lineNum">     224 </span>                :            :      *   for freeing '*devnamep' (with free()) when it no longer needs it.
<span class="lineNum">     225 </span>                :            :      *
<span class="lineNum">     226 </span>                :            :      * - Alternatively: return ENOBUFS, without indicating the device that was
<span class="lineNum">     227 </span>                :            :      *   added or deleted.
<span class="lineNum">     228 </span>                :            :      *
<span class="lineNum">     229 </span>                :            :      * Occasional 'false positives', in which the function returns 0 while
<span class="lineNum">     230 </span>                :            :      * indicating a device that was not actually added or deleted or returns
<span class="lineNum">     231 </span>                :            :      * ENOBUFS without any change, are acceptable.
<span class="lineNum">     232 </span>                :            :      *
<span class="lineNum">     233 </span>                :            :      * If the set of ports in 'dpif' has not changed, returns EAGAIN.  May also
<span class="lineNum">     234 </span>                :            :      * return other positive errno values to indicate that something has gone
<span class="lineNum">     235 </span>                :            :      * wrong. */
<span class="lineNum">     236 </span>                :            :     int (*port_poll)(const struct dpif *dpif, char **devnamep);
<span class="lineNum">     237 </span>                :            : 
<span class="lineNum">     238 </span>                :            :     /* Arranges for the poll loop to wake up when 'port_poll' will return a
<span class="lineNum">     239 </span>                :            :      * value other than EAGAIN. */
<span class="lineNum">     240 </span>                :            :     void (*port_poll_wait)(const struct dpif *dpif);
<span class="lineNum">     241 </span>                :            : 
<span class="lineNum">     242 </span>                :            :     /* Queries 'dpif' for a flow entry.  The flow is specified by the Netlink
<span class="lineNum">     243 </span>                :            :      * attributes with types OVS_KEY_ATTR_* in the 'key_len' bytes starting at
<span class="lineNum">     244 </span>                :            :      * 'key'.
<span class="lineNum">     245 </span>                :            :      *
<span class="lineNum">     246 </span>                :            :      * Returns 0 if successful.  If no flow matches, returns ENOENT.  On other
<span class="lineNum">     247 </span>                :            :      * failure, returns a positive errno value.
<span class="lineNum">     248 </span>                :            :      *
<span class="lineNum">     249 </span>                :            :      * If 'actionsp' is nonnull, then on success '*actionsp' must be set to an
<span class="lineNum">     250 </span>                :            :      * ofpbuf owned by the caller that contains the Netlink attributes for the
<span class="lineNum">     251 </span>                :            :      * flow's actions.  The caller must free the ofpbuf (with ofpbuf_delete())
<span class="lineNum">     252 </span>                :            :      * when it is no longer needed.
<span class="lineNum">     253 </span>                :            :      *
<span class="lineNum">     254 </span>                :            :      * If 'stats' is nonnull, then on success it must be updated with the
<span class="lineNum">     255 </span>                :            :      * flow's statistics. */
<span class="lineNum">     256 </span>                :            :     int (*flow_get)(const struct dpif *dpif,
<span class="lineNum">     257 </span>                :            :                     const struct nlattr *key, size_t key_len,
<span class="lineNum">     258 </span>                :            :                     struct ofpbuf **actionsp, struct dpif_flow_stats *stats);
<span class="lineNum">     259 </span>                :            : 
<span class="lineNum">     260 </span>                :            :     /* Adds or modifies a flow in 'dpif'.  The flow is specified by the Netlink
<span class="lineNum">     261 </span>                :            :      * attributes with types OVS_KEY_ATTR_* in the 'put-&gt;key_len' bytes
<span class="lineNum">     262 </span>                :            :      * starting at 'put-&gt;key'.  The associated actions are specified by the
<span class="lineNum">     263 </span>                :            :      * Netlink attributes with types OVS_ACTION_ATTR_* in the
<span class="lineNum">     264 </span>                :            :      * 'put-&gt;actions_len' bytes starting at 'put-&gt;actions'.
<span class="lineNum">     265 </span>                :            :      *
<span class="lineNum">     266 </span>                :            :      * - If the flow's key does not exist in 'dpif', then the flow will be
<span class="lineNum">     267 </span>                :            :      *   added if 'put-&gt;flags' includes DPIF_FP_CREATE.  Otherwise the
<span class="lineNum">     268 </span>                :            :      *   operation will fail with ENOENT.
<span class="lineNum">     269 </span>                :            :      *
<span class="lineNum">     270 </span>                :            :      *   If the operation succeeds, then 'put-&gt;stats', if nonnull, must be
<span class="lineNum">     271 </span>                :            :      *   zeroed.
<span class="lineNum">     272 </span>                :            :      *
<span class="lineNum">     273 </span>                :            :      * - If the flow's key does exist in 'dpif', then the flow's actions will
<span class="lineNum">     274 </span>                :            :      *   be updated if 'put-&gt;flags' includes DPIF_FP_MODIFY.  Otherwise the
<span class="lineNum">     275 </span>                :            :      *   operation will fail with EEXIST.  If the flow's actions are updated,
<span class="lineNum">     276 </span>                :            :      *   then its statistics will be zeroed if 'put-&gt;flags' includes
<span class="lineNum">     277 </span>                :            :      *   DPIF_FP_ZERO_STATS, and left as-is otherwise.
<span class="lineNum">     278 </span>                :            :      *
<span class="lineNum">     279 </span>                :            :      *   If the operation succeeds, then 'put-&gt;stats', if nonnull, must be set
<span class="lineNum">     280 </span>                :            :      *   to the flow's statistics before the update.
<span class="lineNum">     281 </span>                :            :      */
<span class="lineNum">     282 </span>                :            :     int (*flow_put)(struct dpif *dpif, const struct dpif_flow_put *put);
<span class="lineNum">     283 </span>                :            : 
<span class="lineNum">     284 </span>                :            :     /* Deletes a flow from 'dpif' and returns 0, or returns ENOENT if 'dpif'
<span class="lineNum">     285 </span>                :            :      * does not contain such a flow.  The flow is specified by the Netlink
<span class="lineNum">     286 </span>                :            :      * attributes with types OVS_KEY_ATTR_* in the 'del-&gt;key_len' bytes
<span class="lineNum">     287 </span>                :            :      * starting at 'del-&gt;key'.
<span class="lineNum">     288 </span>                :            :      *
<span class="lineNum">     289 </span>                :            :      * If the operation succeeds, then 'del-&gt;stats', if nonnull, must be set to
<span class="lineNum">     290 </span>                :            :      * the flow's statistics before its deletion. */
<span class="lineNum">     291 </span>                :            :     int (*flow_del)(struct dpif *dpif, const struct dpif_flow_del *del);
<span class="lineNum">     292 </span>                :            : 
<span class="lineNum">     293 </span>                :            :     /* Deletes all flows from 'dpif' and clears all of its queues of received
<span class="lineNum">     294 </span>                :            :      * packets. */
<span class="lineNum">     295 </span>                :            :     int (*flow_flush)(struct dpif *dpif);
<span class="lineNum">     296 </span>                :            : 
<span class="lineNum">     297 </span>                :            :     /* Flow dumping interface.
<span class="lineNum">     298 </span>                :            :      *
<span class="lineNum">     299 </span>                :            :      * This is the back-end for the flow dumping interface described in
<span class="lineNum">     300 </span>                :            :      * dpif.h.  Please read the comments there first, because this code
<span class="lineNum">     301 </span>                :            :      * closely follows it.
<span class="lineNum">     302 </span>                :            :      *
<span class="lineNum">     303 </span>                :            :      * 'flow_dump_create' and 'flow_dump_thread_create' must always return an
<span class="lineNum">     304 </span>                :            :      * initialized and usable data structure and defer error return until
<span class="lineNum">     305 </span>                :            :      * flow_dump_destroy().  This hasn't been a problem for the dpifs that
<span class="lineNum">     306 </span>                :            :      * exist so far.
<span class="lineNum">     307 </span>                :            :      *
<span class="lineNum">     308 </span>                :            :      * 'flow_dump_create' and 'flow_dump_thread_create' must initialize the
<span class="lineNum">     309 </span>                :            :      * structures that they return with dpif_flow_dump_init() and
<span class="lineNum">     310 </span>                :            :      * dpif_flow_dump_thread_init(), respectively. */
<span class="lineNum">     311 </span>                :            :     struct dpif_flow_dump *(*flow_dump_create)(const struct dpif *dpif);
<span class="lineNum">     312 </span>                :            :     int (*flow_dump_destroy)(struct dpif_flow_dump *dump);
<span class="lineNum">     313 </span>                :            : 
<span class="lineNum">     314 </span>                :            :     struct dpif_flow_dump_thread *(*flow_dump_thread_create)(
<span class="lineNum">     315 </span>                :            :         struct dpif_flow_dump *dump);
<span class="lineNum">     316 </span>                :            :     void (*flow_dump_thread_destroy)(struct dpif_flow_dump_thread *thread);
<span class="lineNum">     317 </span>                :            : 
<span class="lineNum">     318 </span>                :            :     int (*flow_dump_next)(struct dpif_flow_dump_thread *thread,
<span class="lineNum">     319 </span>                :            :                           struct dpif_flow *flows, int max_flows);
<span class="lineNum">     320 </span>                :            : 
<span class="lineNum">     321 </span>                :            :     /* Performs the 'execute-&gt;actions_len' bytes of actions in
<span class="lineNum">     322 </span>                :            :      * 'execute-&gt;actions' on the Ethernet frame in 'execute-&gt;packet'
<span class="lineNum">     323 </span>                :            :      * and on the packet metadata in 'execute-&gt;md'.
<span class="lineNum">     324 </span>                :            :      * May modify both packet and metadata. */
<span class="lineNum">     325 </span>                :            :     int (*execute)(struct dpif *dpif, struct dpif_execute *execute);
<span class="lineNum">     326 </span>                :            : 
<span class="lineNum">     327 </span>                :            :     /* Executes each of the 'n_ops' operations in 'ops' on 'dpif', in the order
<span class="lineNum">     328 </span>                :            :      * in which they are specified, placing each operation's results in the
<span class="lineNum">     329 </span>                :            :      * &quot;output&quot; members documented in comments.
<span class="lineNum">     330 </span>                :            :      *
<span class="lineNum">     331 </span>                :            :      * This function is optional.  It is only worthwhile to implement it if
<span class="lineNum">     332 </span>                :            :      * 'dpif' can perform operations in batch faster than individually. */
<span class="lineNum">     333 </span>                :            :     void (*operate)(struct dpif *dpif, struct dpif_op **ops, size_t n_ops);
<span class="lineNum">     334 </span>                :            : 
<span class="lineNum">     335 </span>                :            :     /* Enables or disables receiving packets with dpif_recv() for 'dpif'.
<span class="lineNum">     336 </span>                :            :      * Turning packet receive off and then back on is allowed to change Netlink
<span class="lineNum">     337 </span>                :            :      * PID assignments (see -&gt;port_get_pid()).  The client is responsible for
<span class="lineNum">     338 </span>                :            :      * updating flows as necessary if it does this. */
<span class="lineNum">     339 </span>                :            :     int (*recv_set)(struct dpif *dpif, bool enable);
<span class="lineNum">     340 </span>                :            : 
<span class="lineNum">     341 </span>                :            :     /* Refreshes the poll loops and Netlink sockets associated to each port,
<span class="lineNum">     342 </span>                :            :      * when the number of upcall handlers (upcall receiving thread) is changed
<span class="lineNum">     343 </span>                :            :      * to 'n_handlers' and receiving packets for 'dpif' is enabled by
<span class="lineNum">     344 </span>                :            :      * recv_set().
<span class="lineNum">     345 </span>                :            :      *
<span class="lineNum">     346 </span>                :            :      * Since multiple upcall handlers can read upcalls simultaneously from
<span class="lineNum">     347 </span>                :            :      * 'dpif', each port can have multiple Netlink sockets, one per upcall
<span class="lineNum">     348 </span>                :            :      * handler.  So, handlers_set() is responsible for the following tasks:
<span class="lineNum">     349 </span>                :            :      *
<span class="lineNum">     350 </span>                :            :      *    When receiving upcall is enabled, extends or creates the
<span class="lineNum">     351 </span>                :            :      *    configuration to support:
<span class="lineNum">     352 </span>                :            :      *
<span class="lineNum">     353 </span>                :            :      *        - 'n_handlers' Netlink sockets for each port.
<span class="lineNum">     354 </span>                :            :      *
<span class="lineNum">     355 </span>                :            :      *        - 'n_handlers' poll loops, one for each upcall handler.
<span class="lineNum">     356 </span>                :            :      *
<span class="lineNum">     357 </span>                :            :      *        - registering the Netlink sockets for the same upcall handler to
<span class="lineNum">     358 </span>                :            :      *          the corresponding poll loop.
<span class="lineNum">     359 </span>                :            :      * */
<span class="lineNum">     360 </span>                :            :     int (*handlers_set)(struct dpif *dpif, uint32_t n_handlers);
<span class="lineNum">     361 </span>                :            : 
<span class="lineNum">     362 </span>                :            :     /* Translates OpenFlow queue ID 'queue_id' (in host byte order) into a
<span class="lineNum">     363 </span>                :            :      * priority value used for setting packet priority. */
<span class="lineNum">     364 </span>                :            :     int (*queue_to_priority)(const struct dpif *dpif, uint32_t queue_id,
<span class="lineNum">     365 </span>                :            :                              uint32_t *priority);
<span class="lineNum">     366 </span>                :            : 
<span class="lineNum">     367 </span>                :            :     /* Polls for an upcall from 'dpif' for an upcall handler.  Since there
<span class="lineNum">     368 </span>                :            :      * can be multiple poll loops (see -&gt;handlers_set()), 'handler_id' is
<span class="lineNum">     369 </span>                :            :      * needed as index to identify the corresponding poll loop.  If
<span class="lineNum">     370 </span>                :            :      * successful, stores the upcall into '*upcall', using 'buf' for
<span class="lineNum">     371 </span>                :            :      * storage.  Should only be called if 'recv_set' has been used to enable
<span class="lineNum">     372 </span>                :            :      * receiving packets from 'dpif'.
<span class="lineNum">     373 </span>                :            :      *
<span class="lineNum">     374 </span>                :            :      * The implementation should point 'upcall-&gt;key' and 'upcall-&gt;userdata'
<span class="lineNum">     375 </span>                :            :      * (if any) into data in the caller-provided 'buf'.  The implementation may
<span class="lineNum">     376 </span>                :            :      * also use 'buf' for storing the data of 'upcall-&gt;packet'.  If necessary
<span class="lineNum">     377 </span>                :            :      * to make room, the implementation may reallocate the data in 'buf'.
<span class="lineNum">     378 </span>                :            :      *
<span class="lineNum">     379 </span>                :            :      * The caller owns the data of 'upcall-&gt;packet' and may modify it.  If
<span class="lineNum">     380 </span>                :            :      * packet's headroom is exhausted as it is manipulated, 'upcall-&gt;packet'
<span class="lineNum">     381 </span>                :            :      * will be reallocated.  This requires the data of 'upcall-&gt;packet' to be
<span class="lineNum">     382 </span>                :            :      * released with ofpbuf_uninit() before 'upcall' is destroyed.  However,
<span class="lineNum">     383 </span>                :            :      * when an error is returned, the 'upcall-&gt;packet' may be uninitialized
<span class="lineNum">     384 </span>                :            :      * and should not be released.
<span class="lineNum">     385 </span>                :            :      *
<span class="lineNum">     386 </span>                :            :      * This function must not block.  If no upcall is pending when it is
<span class="lineNum">     387 </span>                :            :      * called, it should return EAGAIN without blocking. */
<span class="lineNum">     388 </span>                :            :     int (*recv)(struct dpif *dpif, uint32_t handler_id,
<span class="lineNum">     389 </span>                :            :                 struct dpif_upcall *upcall, struct ofpbuf *buf);
<span class="lineNum">     390 </span>                :            : 
<span class="lineNum">     391 </span>                :            :     /* Arranges for the poll loop for an upcall handler to wake up when 'dpif'
<span class="lineNum">     392 </span>                :            :      * has a message queued to be received with the recv member functions.
<span class="lineNum">     393 </span>                :            :      * Since there can be multiple poll loops (see -&gt;handlers_set()),
<span class="lineNum">     394 </span>                :            :      * 'handler_id' is needed as index to identify the corresponding poll loop.
<span class="lineNum">     395 </span>                :            :      * */
<span class="lineNum">     396 </span>                :            :     void (*recv_wait)(struct dpif *dpif, uint32_t handler_id);
<span class="lineNum">     397 </span>                :            : 
<span class="lineNum">     398 </span>                :            :     /* Throws away any queued upcalls that 'dpif' currently has ready to
<span class="lineNum">     399 </span>                :            :      * return. */
<span class="lineNum">     400 </span>                :            :     void (*recv_purge)(struct dpif *dpif);
<span class="lineNum">     401 </span>                :            : };
<span class="lineNum">     402 </span>                :            : 
<span class="lineNum">     403 </span>                :            : extern const struct dpif_class dpif_linux_class;
<span class="lineNum">     404 </span>                :            : extern const struct dpif_class dpif_netdev_class;
<span class="lineNum">     405 </span>                :            : 
<span class="lineNum">     406 </span>                :            : #ifdef  __cplusplus
<span class="lineNum">     407 </span>                :            : }
<span class="lineNum">     408 </span>                :            : #endif
<span class="lineNum">     409 </span>                :            : 
<span class="lineNum">     410 </span>                :            : #endif /* dpif-provider.h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.9</a></td></tr>
  </table>
  <br>

</body>
</html>
