<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - lib/classifier-private.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">lib</a> - classifier-private.h<span style="font-size: 80%;"> (source / <a href="classifier-private.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">81</td>
            <td class="headerCovTableEntry">81</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-09-14 01:02:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntryHi">95.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : /*</a>
<span class="lineNum">       2 </span>                :            :  * Copyright (c) 2014, 2015, 2016 Nicira, Inc.
<span class="lineNum">       3 </span>                :            :  *
<span class="lineNum">       4 </span>                :            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       5 </span>                :            :  * you may not use this file except in compliance with the License.
<span class="lineNum">       6 </span>                :            :  * You may obtain a copy of the License at:
<span class="lineNum">       7 </span>                :            :  *
<span class="lineNum">       8 </span>                :            :  *     http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">       9 </span>                :            :  *
<span class="lineNum">      10 </span>                :            :  * Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      11 </span>                :            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      12 </span>                :            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      13 </span>                :            :  * See the License for the specific language governing permissions and
<span class="lineNum">      14 </span>                :            :  * limitations under the License.
<span class="lineNum">      15 </span>                :            :  */
<span class="lineNum">      16 </span>                :            : 
<span class="lineNum">      17 </span>                :            : #ifndef CLASSIFIER_PRIVATE_H
<span class="lineNum">      18 </span>                :            : #define CLASSIFIER_PRIVATE_H 1
<span class="lineNum">      19 </span>                :            : 
<span class="lineNum">      20 </span>                :            : #include &quot;ccmap.h&quot;
<span class="lineNum">      21 </span>                :            : #include &quot;cmap.h&quot;
<span class="lineNum">      22 </span>                :            : #include &quot;flow.h&quot;
<span class="lineNum">      23 </span>                :            : #include &quot;hash.h&quot;
<span class="lineNum">      24 </span>                :            : #include &quot;rculist.h&quot;
<span class="lineNum">      25 </span>                :            : 
<span class="lineNum">      26 </span>                :            : /* Classifier internal definitions, subject to change at any time. */
<span class="lineNum">      27 </span>                :            : 
<span class="lineNum">      28 </span>                :            : /* A set of rules that all have the same fields wildcarded. */
<span class="lineNum">      29 </span>                :            : struct cls_subtable {
<span class="lineNum">      30 </span>                :            :     struct cmap_node cmap_node;    /* Within classifier's 'subtables_map'. */
<span class="lineNum">      31 </span>                :            : 
<span class="lineNum">      32 </span>                :            :     /* These fields are only used by writers. */
<span class="lineNum">      33 </span>                :            :     int max_priority;              /* Max priority of any rule in subtable. */
<span class="lineNum">      34 </span>                :            :     unsigned int max_count;        /* Count of max_priority rules. */
<span class="lineNum">      35 </span>                :            : 
<span class="lineNum">      36 </span>                :            :     /* Accessed by iterators. */
<span class="lineNum">      37 </span>                :            :     struct rculist rules_list;              /* Unordered. */
<span class="lineNum">      38 </span>                :            : 
<span class="lineNum">      39 </span>                :            :     /* Identical, but lower priority rules are not inserted to any of the
<span class="lineNum">      40 </span>                :            :      * following data structures. */
<span class="lineNum">      41 </span>                :            : 
<span class="lineNum">      42 </span>                :            :     /* These fields are accessed by readers who care about wildcarding. */
<span class="lineNum">      43 </span>                :            :     const uint8_t n_indices;                   /* How many indices to use. */
<span class="lineNum">      44 </span>                :            :     const struct flowmap index_maps[CLS_MAX_INDICES + 1]; /* Stage maps. */
<span class="lineNum">      45 </span>                :            :     unsigned int trie_plen[CLS_MAX_TRIES];  /* Trie prefix length in 'mask'
<span class="lineNum">      46 </span>                :            :                                              * (runtime configurable). */
<span class="lineNum">      47 </span>                :            :     const int ports_mask_len;
<span class="lineNum">      48 </span>                :            :     struct ccmap indices[CLS_MAX_INDICES];  /* Staged lookup indices. */
<span class="lineNum">      49 </span>                :            :     rcu_trie_ptr ports_trie;                /* NULL if none. */
<span class="lineNum">      50 </span>                :            : 
<span class="lineNum">      51 </span>                :            :     /* These fields are accessed by all readers. */
<span class="lineNum">      52 </span>                :            :     struct cmap rules;                      /* Contains 'cls_match'es. */
<span class="lineNum">      53 </span>                :            :     const struct minimask mask;             /* Wildcards for fields. */
<span class="lineNum">      54 </span>                :            :     /* 'mask' must be the last field. */
<span class="lineNum">      55 </span>                :            : };
<span class="lineNum">      56 </span>                :            : 
<span class="lineNum">      57 </span>                :            : /* Internal representation of a rule in a &quot;struct cls_subtable&quot;.
<span class="lineNum">      58 </span>                :            :  *
<span class="lineNum">      59 </span>                :            :  * The 'next' member is an element in a singly linked, null-terminated list.
<span class="lineNum">      60 </span>                :            :  * This list links together identical &quot;cls_match&quot;es in order of decreasing
<span class="lineNum">      61 </span>                :            :  * priority.  The classifier code maintains the invariant that at most one rule
<span class="lineNum">      62 </span>                :            :  * of a given priority is visible for any given lookup version.
<span class="lineNum">      63 </span>                :            :  */
<span class="lineNum">      64 </span>                :            : struct cls_match {
<span class="lineNum">      65 </span>                :            :     /* Accessed by everybody. */
<span class="lineNum">      66 </span>                :            :     OVSRCU_TYPE(struct cls_match *) next; /* Equal, lower-priority matches. */
<span class="lineNum">      67 </span>                :            :     OVSRCU_TYPE(struct cls_conjunction_set *) conj_set;
<span class="lineNum">      68 </span>                :            : 
<span class="lineNum">      69 </span>                :            :     /* Accessed by readers interested in wildcarding. */
<span class="lineNum">      70 </span>                :            :     const int priority;         /* Larger numbers are higher priorities. */
<span class="lineNum">      71 </span>                :            : 
<span class="lineNum">      72 </span>                :            :     /* Accessed by all readers. */
<span class="lineNum">      73 </span>                :            :     struct cmap_node cmap_node; /* Within struct cls_subtable 'rules'. */
<span class="lineNum">      74 </span>                :            : 
<span class="lineNum">      75 </span>                :            :     /* Rule versioning. */
<span class="lineNum">      76 </span>                :            :     struct versions versions;
<span class="lineNum">      77 </span>                :            : 
<span class="lineNum">      78 </span>                :            :     const struct cls_rule *cls_rule;
<span class="lineNum">      79 </span>                :            :     const struct miniflow flow; /* Matching rule. Mask is in the subtable. */
<span class="lineNum">      80 </span>                :            :     /* 'flow' must be the last field. */
<span class="lineNum">      81 </span>                :            : };
<span class="lineNum">      82 </span>                :            : 
<a name="83"><span class="lineNum">      83 </span>                :            : /* Utilities for accessing the 'cls_match' member of struct cls_rule. */</a>
<span class="lineNum">      84 </span>                :            : static inline struct cls_match *
<span class="lineNum">      85 </span>                :<span class="lineCov">     972199 : get_cls_match_protected(const struct cls_rule *rule)</span>
<span class="lineNum">      86 </span>                :            : {
<span class="lineNum">      87 </span>                :<span class="lineCov">     972199 :     return ovsrcu_get_protected(struct cls_match *, &amp;rule-&gt;cls_match);</span>
<span class="lineNum">      88 </span>                :            : }
<a name="89"><span class="lineNum">      89 </span>                :            : </a>
<span class="lineNum">      90 </span>                :            : static inline struct cls_match *
<span class="lineNum">      91 </span>                :<span class="lineCov">    1850516 : get_cls_match(const struct cls_rule *rule)</span>
<span class="lineNum">      92 </span>                :            : {
<span class="lineNum">      93 </span>                :<span class="lineCov">    1850516 :     return ovsrcu_get(struct cls_match *, &amp;rule-&gt;cls_match);</span>
<span class="lineNum">      94 </span>                :            : }
<span class="lineNum">      95 </span>                :            : 
<span class="lineNum">      96 </span>                :            : /* Must be RCU postponed. */
<span class="lineNum">      97 </span>                :            : void cls_match_free_cb(struct cls_match *);
<a name="98"><span class="lineNum">      98 </span>                :            : </a>
<span class="lineNum">      99 </span>                :            : static inline void
<span class="lineNum">     100 </span>                :<span class="lineCov">     523023 : cls_match_set_remove_version(struct cls_match *rule, ovs_version_t version)</span>
<span class="lineNum">     101 </span>                :            : {
<span class="lineNum">     102 </span>                :<span class="lineCov">     523023 :     versions_set_remove_version(&amp;rule-&gt;versions, version);</span>
<span class="lineNum">     103 </span>                :<span class="lineCov">     523023 : }</span>
<a name="104"><span class="lineNum">     104 </span>                :            : </a>
<span class="lineNum">     105 </span>                :            : static inline bool
<span class="lineNum">     106 </span>                :<span class="lineCov">   13358727 : cls_match_visible_in_version(const struct cls_match *rule,</span>
<span class="lineNum">     107 </span>                :            :                              ovs_version_t version)
<span class="lineNum">     108 </span>                :            : {
<span class="lineNum">     109 </span>                :<span class="lineCov">   13358727 :     return versions_visible_in_version(&amp;rule-&gt;versions, version);</span>
<span class="lineNum">     110 </span>                :            : }
<a name="111"><span class="lineNum">     111 </span>                :            : </a>
<span class="lineNum">     112 </span>                :            : static inline bool
<span class="lineNum">     113 </span>                :<span class="lineCov">     468166 : cls_match_is_eventually_invisible(const struct cls_match *rule)</span>
<span class="lineNum">     114 </span>                :            : {
<span class="lineNum">     115 </span>                :<span class="lineCov">     468166 :     return versions_is_eventually_invisible(&amp;rule-&gt;versions);</span>
<span class="lineNum">     116 </span>                :            : }
<span class="lineNum">     117 </span>                :            : 
<span class="lineNum">     118 </span>                :            : 
<span class="lineNum">     119 </span>                :            : /* cls_match 'next' */
<a name="120"><span class="lineNum">     120 </span>                :            : </a>
<span class="lineNum">     121 </span>                :            : static inline const struct cls_match *
<span class="lineNum">     122 </span>                :<span class="lineCov">      38921 : cls_match_next(const struct cls_match *rule)</span>
<span class="lineNum">     123 </span>                :            : {
<span class="lineNum">     124 </span>                :<span class="lineCov">      38921 :     return ovsrcu_get(struct cls_match *, &amp;rule-&gt;next);</span>
<span class="lineNum">     125 </span>                :            : }
<a name="126"><span class="lineNum">     126 </span>                :            : </a>
<span class="lineNum">     127 </span>                :            : static inline struct cls_match *
<span class="lineNum">     128 </span>                :<span class="lineCov">    1174237 : cls_match_next_protected(const struct cls_match *rule)</span>
<span class="lineNum">     129 </span>                :            : {
<span class="lineNum">     130 </span>                :<span class="lineCov">    1174237 :     return ovsrcu_get_protected(struct cls_match *, &amp;rule-&gt;next);</span>
<span class="lineNum">     131 </span>                :            : }
<span class="lineNum">     132 </span>                :            : 
<span class="lineNum">     133 </span>                :            : /* Puts 'rule' in the position between 'prev' and 'next'.  If 'prev' == NULL,
<span class="lineNum">     134 </span>                :            :  * then the 'rule' is the new list head, and if 'next' == NULL, the rule is the
<span class="lineNum">     135 </span>                :            :  * new list tail.
<span class="lineNum">     136 </span>                :            :  * If there are any nodes between 'prev' and 'next', they are dropped from the
<a name="137"><span class="lineNum">     137 </span>                :            :  * list. */</a>
<span class="lineNum">     138 </span>                :            : static inline void
<span class="lineNum">     139 </span>                :<span class="lineCov">      25106 : cls_match_insert(struct cls_match *prev, struct cls_match *next,</span>
<span class="lineNum">     140 </span>                :            :                  struct cls_match *rule)
<span class="lineNum">     141 </span>                :            : {
<span class="lineNum">     142 </span>                :<span class="lineCov">      25106 :     ovsrcu_set_hidden(&amp;rule-&gt;next, next);</span>
<span class="lineNum">     143 </span>                :            : 
<span class="lineNum">     144 </span>        [<span class="branchCov" title="Branch 0 was taken 1787 times"> + </span><span class="branchCov" title="Branch 1 was taken 23319 times"> + </span>]:<span class="lineCov">      25106 :     if (prev) {</span>
<span class="lineNum">     145 </span>                :<span class="lineCov">       1787 :         ovsrcu_set(&amp;prev-&gt;next, rule);</span>
<span class="lineNum">     146 </span>                :            :     }
<span class="lineNum">     147 </span>                :<span class="lineCov">      25106 : }</span>
<span class="lineNum">     148 </span>                :            : 
<span class="lineNum">     149 </span>                :            : /* Puts 'new_rule' in the position of 'old_rule', which is the next node after
<span class="lineNum">     150 </span>                :            :  * 'prev'. If 'prev' == NULL, then the 'new_rule' is the new list head.
<span class="lineNum">     151 </span>                :            :  *
<span class="lineNum">     152 </span>                :            :  * The replaced cls_match still links to the later rules, and may still be
<span class="lineNum">     153 </span>                :            :  * referenced by other threads until all other threads quiesce.  The replaced
<span class="lineNum">     154 </span>                :            :  * rule may not be re-inserted, re-initialized, or deleted until after all
<a name="155"><span class="lineNum">     155 </span>                :            :  * other threads have quiesced (use ovsrcu_postpone). */</a>
<span class="lineNum">     156 </span>                :            : static inline void
<span class="lineNum">     157 </span>                :<span class="lineCov">      23075 : cls_match_replace(struct cls_match *prev,</span>
<span class="lineNum">     158 </span>                :            :                   struct cls_match *old_rule, struct cls_match *new_rule)
<span class="lineNum">     159 </span>                :            : {
<span class="lineNum">     160 </span>                :<span class="lineCov">      23075 :     cls_match_insert(prev, cls_match_next_protected(old_rule), new_rule);</span>
<span class="lineNum">     161 </span>                :<span class="lineCov">      23075 : }</span>
<span class="lineNum">     162 </span>                :            : 
<span class="lineNum">     163 </span>                :            : /* Removes 'rule' following 'prev' from the list. If 'prev' is NULL, then the
<span class="lineNum">     164 </span>                :            :  * 'rule' is a list head, and the caller is responsible for maintaining its
<span class="lineNum">     165 </span>                :            :  * list head pointer (if any).
<span class="lineNum">     166 </span>                :            :  *
<span class="lineNum">     167 </span>                :            :  * Afterward, the removed rule is not linked to any more, but still links to
<span class="lineNum">     168 </span>                :            :  * the following rules, and may still be referenced by other threads until all
<span class="lineNum">     169 </span>                :            :  * other threads quiesce.  The removed rule may not be re-inserted,
<span class="lineNum">     170 </span>                :            :  * re-initialized, or deleted until after all other threads have quiesced (use
<span class="lineNum">     171 </span>                :            :  * ovsrcu_postpone).
<a name="172"><span class="lineNum">     172 </span>                :            :  */</a>
<span class="lineNum">     173 </span>                :            : static inline void
<span class="lineNum">     174 </span>                :<span class="lineCov">        300 : cls_match_remove(struct cls_match *prev, struct cls_match *rule)</span>
<span class="lineNum">     175 </span>                :            : {
<span class="lineNum">     176 </span>        [<span class="branchCov" title="Branch 0 was taken 300 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">        300 :     if (prev) {</span>
<span class="lineNum">     177 </span>                :<span class="lineCov">        300 :         ovsrcu_set(&amp;prev-&gt;next, cls_match_next_protected(rule));</span>
<span class="lineNum">     178 </span>                :            :     }
<span class="lineNum">     179 </span>                :<span class="lineCov">        300 : }</span>
<span class="lineNum">     180 </span>                :            : 
<span class="lineNum">     181 </span>                :            : #define CLS_MATCH_FOR_EACH(ITER, HEAD)                              \
<span class="lineNum">     182 </span>                :            :     for ((ITER) = (HEAD); (ITER); (ITER) = cls_match_next(ITER))
<span class="lineNum">     183 </span>                :            : 
<span class="lineNum">     184 </span>                :            : #define CLS_MATCH_FOR_EACH_AFTER_HEAD(ITER, HEAD)   \
<span class="lineNum">     185 </span>                :            :     CLS_MATCH_FOR_EACH(ITER, cls_match_next(HEAD))
<span class="lineNum">     186 </span>                :            : 
<span class="lineNum">     187 </span>                :            : /* Iterate cls_matches keeping the previous pointer for modifications. */
<span class="lineNum">     188 </span>                :            : #define FOR_EACH_RULE_IN_LIST_PROTECTED(ITER, PREV, HEAD)           \
<span class="lineNum">     189 </span>                :            :     for ((PREV) = NULL, (ITER) = (HEAD);                            \
<span class="lineNum">     190 </span>                :            :          (ITER);                                                    \
<span class="lineNum">     191 </span>                :            :          (PREV) = (ITER), (ITER) = cls_match_next_protected(ITER))
<span class="lineNum">     192 </span>                :            : 
<span class="lineNum">     193 </span>                :            : 
<span class="lineNum">     194 </span>                :            : /* A longest-prefix match tree. */
<span class="lineNum">     195 </span>                :            : struct trie_node {
<span class="lineNum">     196 </span>                :            :     uint32_t prefix;           /* Prefix bits for this node, MSB first. */
<span class="lineNum">     197 </span>                :            :     uint8_t  n_bits;           /* Never zero, except for the root node. */
<span class="lineNum">     198 </span>                :            :     unsigned int n_rules;      /* Number of rules that have this prefix. */
<span class="lineNum">     199 </span>                :            :     rcu_trie_ptr edges[2];     /* Both NULL if leaf. */
<span class="lineNum">     200 </span>                :            : };
<span class="lineNum">     201 </span>                :            : 
<span class="lineNum">     202 </span>                :            : /* Max bits per node.  Must fit in struct trie_node's 'prefix'.
<span class="lineNum">     203 </span>                :            :  * Also tested with 16, 8, and 5 to stress the implementation. */
<span class="lineNum">     204 </span>                :            : #define TRIE_PREFIX_BITS 32
<span class="lineNum">     205 </span>                :            : 
<span class="lineNum">     206 </span>                :            : /* flow/miniflow/minimask/minimatch utilities.
<span class="lineNum">     207 </span>                :            :  * These are only used by the classifier, so place them here to allow
<span class="lineNum">     208 </span>                :            :  * for better optimization. */
<span class="lineNum">     209 </span>                :            : 
<span class="lineNum">     210 </span>                :            : /* Returns a hash value for the bits of 'flow' where there are 1-bits in
<span class="lineNum">     211 </span>                :            :  * 'mask', given 'basis'.
<span class="lineNum">     212 </span>                :            :  *
<span class="lineNum">     213 </span>                :            :  * The hash values returned by this function are the same as those returned by
<a name="214"><span class="lineNum">     214 </span>                :            :  * miniflow_hash_in_minimask(), only the form of the arguments differ. */</a>
<span class="lineNum">     215 </span>                :            : static inline uint32_t
<span class="lineNum">     216 </span>                :<span class="lineCov">   58733642 : flow_hash_in_minimask(const struct flow *flow, const struct minimask *mask,</span>
<span class="lineNum">     217 </span>                :            :                       uint32_t basis)
<span class="lineNum">     218 </span>                :            : {
<span class="lineNum">     219 </span>                :<span class="lineCov">   58733642 :     const uint64_t *mask_values = miniflow_get_values(&amp;mask-&gt;masks);</span>
<span class="lineNum">     220 </span>                :<span class="lineCov">   58733642 :     const uint64_t *flow_u64 = (const uint64_t *)flow;</span>
<span class="lineNum">     221 </span>                :<span class="lineCov">   58733642 :     const uint64_t *p = mask_values;</span>
<span class="lineNum">     222 </span>                :<span class="lineCov">   58733642 :     uint32_t hash = basis;</span>
<span class="lineNum">     223 </span>                :            :     map_t map;
<span class="lineNum">     224 </span>                :            : 
<span class="lineNum">     225 </span>        [<span class="branchCov" title="Branch 0 was taken 117467284 times"> + </span><span class="branchCov" title="Branch 1 was taken 58733642 times"> + </span>]:<span class="lineCov">  176200926 :     FLOWMAP_FOR_EACH_MAP (map, mask-&gt;masks.map) {</span>
<span class="lineNum">     226 </span>                :            :         size_t idx;
<span class="lineNum">     227 </span>                :            : 
<span class="lineNum">     228 </span>        [<span class="branchCov" title="Branch 1 was taken 242359429 times"> + </span><span class="branchCov" title="Branch 2 was taken 117467284 times"> + </span>]:<span class="lineCov">  359826713 :         MAP_FOR_EACH_INDEX (idx, map) {</span>
<span class="lineNum">     229 </span>                :<span class="lineCov">  242359429 :             hash = hash_add64(hash, flow_u64[idx] &amp; *p++);</span>
<span class="lineNum">     230 </span>                :            :         }
<span class="lineNum">     231 </span>                :<span class="lineCov">  117467284 :         flow_u64 += MAP_T_BITS;</span>
<span class="lineNum">     232 </span>                :            :     }
<span class="lineNum">     233 </span>                :            : 
<span class="lineNum">     234 </span>                :<span class="lineCov">   58733642 :     return hash_finish(hash, (p - mask_values) * 8);</span>
<span class="lineNum">     235 </span>                :            : }
<span class="lineNum">     236 </span>                :            : 
<span class="lineNum">     237 </span>                :            : /* Returns a hash value for the bits of 'flow' where there are 1-bits in
<span class="lineNum">     238 </span>                :            :  * 'mask', given 'basis'.
<span class="lineNum">     239 </span>                :            :  *
<span class="lineNum">     240 </span>                :            :  * The hash values returned by this function are the same as those returned by
<a name="241"><span class="lineNum">     241 </span>                :            :  * flow_hash_in_minimask(), only the form of the arguments differ. */</a>
<span class="lineNum">     242 </span>                :            : static inline uint32_t
<span class="lineNum">     243 </span>                :<span class="lineCov">     733203 : miniflow_hash_in_minimask(const struct miniflow *flow,</span>
<span class="lineNum">     244 </span>                :            :                           const struct minimask *mask, uint32_t basis)
<span class="lineNum">     245 </span>                :            : {
<span class="lineNum">     246 </span>                :<span class="lineCov">     733203 :     const uint64_t *mask_values = miniflow_get_values(&amp;mask-&gt;masks);</span>
<span class="lineNum">     247 </span>                :<span class="lineCov">     733203 :     const uint64_t *p = mask_values;</span>
<span class="lineNum">     248 </span>                :<span class="lineCov">     733203 :     uint32_t hash = basis;</span>
<span class="lineNum">     249 </span>                :            :     uint64_t value;
<span class="lineNum">     250 </span>                :            : 
<span class="lineNum">     251 </span>        [<span class="branchCov" title="Branch 2 was taken 5582496 times"> + </span><span class="branchCov" title="Branch 3 was taken 733203 times"> + </span>]:<span class="lineCov">    6315699 :     MINIFLOW_FOR_EACH_IN_FLOWMAP(value, flow, mask-&gt;masks.map) {</span>
<span class="lineNum">     252 </span>                :<span class="lineCov">    5582496 :         hash = hash_add64(hash, value &amp; *p++);</span>
<span class="lineNum">     253 </span>                :            :     }
<span class="lineNum">     254 </span>                :            : 
<span class="lineNum">     255 </span>                :<span class="lineCov">     733203 :     return hash_finish(hash, (p - mask_values) * 8);</span>
<span class="lineNum">     256 </span>                :            : }
<span class="lineNum">     257 </span>                :            : 
<span class="lineNum">     258 </span>                :            : /* Returns a hash value for the values of 'flow', indicated by 'range', where
<span class="lineNum">     259 </span>                :            :  * there are 1-bits in 'mask', given 'basis'.  'range' must be a continuous
<span class="lineNum">     260 </span>                :            :  * subset of the bits in 'mask''s map, representing a continuous range of the
<span class="lineNum">     261 </span>                :            :  * minimask's mask data.  '*offset' must be the number of 64-bit units of the
<span class="lineNum">     262 </span>                :            :  * minimask's data to skip to get to the first unit covered by 'range'. On
<span class="lineNum">     263 </span>                :            :  * return '*offset' is updated with the number of 64-bit units of the minimask
<span class="lineNum">     264 </span>                :            :  * consumed.
<span class="lineNum">     265 </span>                :            :  *
<span class="lineNum">     266 </span>                :            :  * Typically this function is called for successive ranges of minimask's masks,
<span class="lineNum">     267 </span>                :            :  * and the first invocation passes '*offset' as zero.
<span class="lineNum">     268 </span>                :            :  *
<span class="lineNum">     269 </span>                :            :  * The hash values returned by this function are the same as those returned by
<a name="270"><span class="lineNum">     270 </span>                :            :  * minimatch_hash_range(), only the form of the arguments differ. */</a>
<span class="lineNum">     271 </span>                :            : static inline uint32_t
<span class="lineNum">     272 </span>                :<span class="lineCov">   41945908 : flow_hash_in_minimask_range(const struct flow *flow,</span>
<span class="lineNum">     273 </span>                :            :                             const struct minimask *mask,
<span class="lineNum">     274 </span>                :            :                             const struct flowmap range,
<span class="lineNum">     275 </span>                :            :                             unsigned int *offset,
<span class="lineNum">     276 </span>                :            :                             uint32_t *basis)
<span class="lineNum">     277 </span>                :            : {
<span class="lineNum">     278 </span>                :<span class="lineCov">   41945908 :     const uint64_t *mask_values = miniflow_get_values(&amp;mask-&gt;masks);</span>
<span class="lineNum">     279 </span>                :<span class="lineCov">   41945903 :     const uint64_t *flow_u64 = (const uint64_t *)flow;</span>
<span class="lineNum">     280 </span>                :<span class="lineCov">   41945903 :     const uint64_t *p = mask_values + *offset;</span>
<span class="lineNum">     281 </span>                :<span class="lineCov">   41945903 :     uint32_t hash = *basis;</span>
<span class="lineNum">     282 </span>                :            :     map_t map;
<span class="lineNum">     283 </span>                :            : 
<span class="lineNum">     284 </span>        [<span class="branchCov" title="Branch 0 was taken 83891808 times"> + </span><span class="branchCov" title="Branch 1 was taken 41945905 times"> + </span>]:<span class="lineCov">  125837713 :     FLOWMAP_FOR_EACH_MAP (map, range) {</span>
<span class="lineNum">     285 </span>                :            :         size_t idx;
<span class="lineNum">     286 </span>                :            : 
<span class="lineNum">     287 </span>        [<span class="branchCov" title="Branch 1 was taken 106169295 times"> + </span><span class="branchCov" title="Branch 2 was taken 83891810 times"> + </span>]:<span class="lineCov">  190061101 :         MAP_FOR_EACH_INDEX (idx, map) {</span>
<span class="lineNum">     288 </span>                :<span class="lineCov">  106169295 :             hash = hash_add64(hash, flow_u64[idx] &amp; *p++);</span>
<span class="lineNum">     289 </span>                :            :         }
<span class="lineNum">     290 </span>                :<span class="lineCov">   83891810 :         flow_u64 += MAP_T_BITS;</span>
<span class="lineNum">     291 </span>                :            :     }
<span class="lineNum">     292 </span>                :            : 
<span class="lineNum">     293 </span>                :<span class="lineCov">   41945905 :     *basis = hash; /* Allow continuation from the unfinished value. */</span>
<span class="lineNum">     294 </span>                :<span class="lineCov">   41945905 :     *offset = p - mask_values;</span>
<span class="lineNum">     295 </span>                :<span class="lineCov">   41945905 :     return hash_finish(hash, *offset * 8);</span>
<span class="lineNum">     296 </span>                :            : }
<span class="lineNum">     297 </span>                :            : 
<a name="298"><span class="lineNum">     298 </span>                :            : /* Fold minimask 'mask''s wildcard mask into 'wc's wildcard mask. */</a>
<span class="lineNum">     299 </span>                :            : static inline void
<span class="lineNum">     300 </span>                :<span class="lineCov">    1895841 : flow_wildcards_fold_minimask(struct flow_wildcards *wc,</span>
<span class="lineNum">     301 </span>                :            :                              const struct minimask *mask)
<span class="lineNum">     302 </span>                :            : {
<span class="lineNum">     303 </span>                :<span class="lineCov">    1895841 :     flow_union_with_miniflow(&amp;wc-&gt;masks, &amp;mask-&gt;masks);</span>
<span class="lineNum">     304 </span>                :<span class="lineCov">    1895840 : }</span>
<span class="lineNum">     305 </span>                :            : 
<span class="lineNum">     306 </span>                :            : /* Fold minimask 'mask''s wildcard mask into 'wc's wildcard mask for bits in
<a name="307"><span class="lineNum">     307 </span>                :            :  * 'fmap'.  1-bits in 'fmap' are a subset of 1-bits in 'mask''s map. */</a>
<span class="lineNum">     308 </span>                :            : static inline void
<span class="lineNum">     309 </span>                :<span class="lineCov">   26168105 : flow_wildcards_fold_minimask_in_map(struct flow_wildcards *wc,</span>
<span class="lineNum">     310 </span>                :            :                                     const struct minimask *mask,
<span class="lineNum">     311 </span>                :            :                                     const struct flowmap fmap)
<span class="lineNum">     312 </span>                :            : {
<span class="lineNum">     313 </span>                :<span class="lineCov">   26168105 :     flow_union_with_miniflow_subset(&amp;wc-&gt;masks, &amp;mask-&gt;masks, fmap);</span>
<span class="lineNum">     314 </span>                :<span class="lineCov">   26168105 : }</span>
<span class="lineNum">     315 </span>                :            : 
<a name="316"><span class="lineNum">     316 </span>                :            : /* Returns a hash value for 'mask', given 'basis'. */</a>
<span class="lineNum">     317 </span>                :            : static inline uint32_t
<span class="lineNum">     318 </span>                :<span class="lineCov">    2489709 : minimask_hash(const struct minimask *mask, uint32_t basis)</span>
<span class="lineNum">     319 </span>                :            : {
<span class="lineNum">     320 </span>                :<span class="lineCov">    2489709 :     const uint64_t *p = miniflow_get_values(&amp;mask-&gt;masks);</span>
<span class="lineNum">     321 </span>                :<span class="lineCov">    2489709 :     size_t n_values = miniflow_n_values(&amp;mask-&gt;masks);</span>
<span class="lineNum">     322 </span>                :<span class="lineCov">    2489709 :     uint32_t hash = basis;</span>
<span class="lineNum">     323 </span>                :            : 
<span class="lineNum">     324 </span>        [<span class="branchCov" title="Branch 0 was taken 8217713 times"> + </span><span class="branchCov" title="Branch 1 was taken 2489709 times"> + </span>]:<span class="lineCov">   10707422 :     for (size_t i = 0; i &lt; n_values; i++) {</span>
<span class="lineNum">     325 </span>                :<span class="lineCov">    8217713 :         hash = hash_add64(hash, *p++);</span>
<span class="lineNum">     326 </span>                :            :     }
<span class="lineNum">     327 </span>                :            : 
<span class="lineNum">     328 </span>                :            :     map_t map;
<span class="lineNum">     329 </span>        [<span class="branchCov" title="Branch 0 was taken 4979418 times"> + </span><span class="branchCov" title="Branch 1 was taken 2489709 times"> + </span>]:<span class="lineCov">    7469127 :     FLOWMAP_FOR_EACH_MAP (map, mask-&gt;masks.map) {</span>
<span class="lineNum">     330 </span>                :<span class="lineCov">    4979418 :         hash = hash_add64(hash, map);</span>
<span class="lineNum">     331 </span>                :            :     }
<span class="lineNum">     332 </span>                :            : 
<span class="lineNum">     333 </span>                :<span class="lineCov">    2489709 :     return hash_finish(hash, n_values);</span>
<span class="lineNum">     334 </span>                :            : }
<span class="lineNum">     335 </span>                :            : 
<span class="lineNum">     336 </span>                :            : /* Returns a hash value for the values of 'match-&gt;flow', indicated by 'range',
<span class="lineNum">     337 </span>                :            :  * where there are 1-bits in 'match-&gt;mask', given 'basis'.  'range' must be a
<span class="lineNum">     338 </span>                :            :  * continuous subset of the bits in the map of 'match', representing a
<span class="lineNum">     339 </span>                :            :  * continuous range of the mask data of 'match'.  '*offset' must be the number
<span class="lineNum">     340 </span>                :            :  * of 64-bit units of the match data to skip to get to the first unit covered
<span class="lineNum">     341 </span>                :            :  * by 'range'.  On return '*offset' is updated with the number of 64-bit units
<span class="lineNum">     342 </span>                :            :  * of the match consumed.
<span class="lineNum">     343 </span>                :            :  *
<span class="lineNum">     344 </span>                :            :  * Typically this function is called for successive ranges of minimask's masks,
<span class="lineNum">     345 </span>                :            :  * and the first invocation passes '*offset' as zero.
<span class="lineNum">     346 </span>                :            :  *
<span class="lineNum">     347 </span>                :            :  * The hash values returned by this function are the same as those returned by
<a name="348"><span class="lineNum">     348 </span>                :            :  * flow_hash_in_minimask_range(), only the form of the arguments differ. */</a>
<span class="lineNum">     349 </span>                :            : static inline uint32_t
<span class="lineNum">     350 </span>                :<span class="lineCov">    1158237 : minimatch_hash_range(const struct minimatch *match,</span>
<span class="lineNum">     351 </span>                :            :                      const struct flowmap range, unsigned int *offset,
<span class="lineNum">     352 </span>                :            :                      uint32_t *basis)
<span class="lineNum">     353 </span>                :            : {
<span class="lineNum">     354 </span>                :<span class="lineCov">    1158237 :     const uint64_t *p = miniflow_get_values(match-&gt;flow) + *offset;</span>
<span class="lineNum">     355 </span>                :<span class="lineCov">    1158237 :     const uint64_t *q = miniflow_get_values(&amp;match-&gt;mask-&gt;masks) + *offset;</span>
<span class="lineNum">     356 </span>                :<span class="lineCov">    1158237 :     unsigned int n = flowmap_n_1bits(range);</span>
<span class="lineNum">     357 </span>                :<span class="lineCov">    1158237 :     uint32_t hash = *basis;</span>
<span class="lineNum">     358 </span>                :            : 
<span class="lineNum">     359 </span>        [<span class="branchCov" title="Branch 0 was taken 1512506 times"> + </span><span class="branchCov" title="Branch 1 was taken 1158237 times"> + </span>]:<span class="lineCov">    2670743 :     for (unsigned int i = 0; i &lt; n; i++) {</span>
<span class="lineNum">     360 </span>                :<span class="lineCov">    1512506 :         hash = hash_add64(hash, p[i] &amp; q[i]);</span>
<span class="lineNum">     361 </span>                :            :     }
<span class="lineNum">     362 </span>                :<span class="lineCov">    1158237 :     *basis = hash; /* Allow continuation from the unfinished value. */</span>
<span class="lineNum">     363 </span>                :<span class="lineCov">    1158237 :     *offset += n;</span>
<span class="lineNum">     364 </span>                :<span class="lineCov">    1158237 :     return hash_finish(hash, *offset * 8);</span>
<span class="lineNum">     365 </span>                :            : }
<span class="lineNum">     366 </span>                :            : 
<span class="lineNum">     367 </span>                :            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
