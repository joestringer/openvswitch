<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - include/openvswitch/util.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">include/openvswitch</a> - util.h<span style="font-size: 80%;"> (source / <a href="util.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-09-14 01:02:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryMed">75.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : /*</a>
<span class="lineNum">       2 </span>                :            :  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Nicira, Inc.
<span class="lineNum">       3 </span>                :            :  *
<span class="lineNum">       4 </span>                :            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       5 </span>                :            :  * you may not use this file except in compliance with the License.
<span class="lineNum">       6 </span>                :            :  * You may obtain a copy of the License at:
<span class="lineNum">       7 </span>                :            :  *
<span class="lineNum">       8 </span>                :            :  *     http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">       9 </span>                :            :  *
<span class="lineNum">      10 </span>                :            :  * Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      11 </span>                :            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      12 </span>                :            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      13 </span>                :            :  * See the License for the specific language governing permissions and
<span class="lineNum">      14 </span>                :            :  * limitations under the License.
<span class="lineNum">      15 </span>                :            :  */
<span class="lineNum">      16 </span>                :            : 
<span class="lineNum">      17 </span>                :            : #ifndef OPENVSWITCH_UTIL_H
<span class="lineNum">      18 </span>                :            : #define OPENVSWITCH_UTIL_H 1
<span class="lineNum">      19 </span>                :            : 
<span class="lineNum">      20 </span>                :            : #include &lt;openvswitch/compiler.h&gt;
<span class="lineNum">      21 </span>                :            : #include &lt;openvswitch/version.h&gt;
<span class="lineNum">      22 </span>                :            : #include &lt;openvswitch/types.h&gt;
<span class="lineNum">      23 </span>                :            : 
<span class="lineNum">      24 </span>                :            : #ifdef __cplusplus
<span class="lineNum">      25 </span>                :            : extern &quot;C&quot; {
<span class="lineNum">      26 </span>                :            : #endif
<span class="lineNum">      27 </span>                :            : 
<span class="lineNum">      28 </span>                :            : void ovs_set_program_name(const char *name, const char *version);
<span class="lineNum">      29 </span>                :            : 
<span class="lineNum">      30 </span>                :            : const char *ovs_get_program_name(void);
<span class="lineNum">      31 </span>                :            : const char *ovs_get_program_version(void);
<span class="lineNum">      32 </span>                :            : 
<span class="lineNum">      33 </span>                :            : /* Expands to a string that looks like &quot;&lt;file&gt;:&lt;line&gt;&quot;, e.g. &quot;tmp.c:10&quot;.
<span class="lineNum">      34 </span>                :            :  *
<span class="lineNum">      35 </span>                :            :  * See http://c-faq.com/ansi/stringize.html for an explanation of OVS_STRINGIZE
<span class="lineNum">      36 </span>                :            :  * and OVS_STRINGIZE2. */
<span class="lineNum">      37 </span>                :            : #define OVS_SOURCE_LOCATOR __FILE__ &quot;:&quot; OVS_STRINGIZE(__LINE__)
<span class="lineNum">      38 </span>                :            : #define OVS_STRINGIZE(ARG) OVS_STRINGIZE2(ARG)
<span class="lineNum">      39 </span>                :            : #define OVS_STRINGIZE2(ARG) #ARG
<span class="lineNum">      40 </span>                :            : 
<span class="lineNum">      41 </span>                :            : /* Saturating multiplication of &quot;unsigned int&quot;s: overflow yields UINT_MAX. */
<span class="lineNum">      42 </span>                :            : #define OVS_SAT_MUL(X, Y)                                               \
<span class="lineNum">      43 </span>                :            :     ((Y) == 0 ? 0                                                       \
<span class="lineNum">      44 </span>                :            :      : (X) &lt;= UINT_MAX / (Y) ? (unsigned int) (X) * (unsigned int) (Y)  \
<span class="lineNum">      45 </span>                :            :      : UINT_MAX)
<span class="lineNum">      46 </span>                :            : 
<span class="lineNum">      47 </span>                :            : /* Like the standard assert macro, except writes the failure message to the
<span class="lineNum">      48 </span>                :            :  * log. */
<span class="lineNum">      49 </span>                :            : #ifndef NDEBUG
<span class="lineNum">      50 </span>                :            : #define ovs_assert(CONDITION)                                           \
<span class="lineNum">      51 </span>                :            :     if (!OVS_LIKELY(CONDITION)) {                                       \
<span class="lineNum">      52 </span>                :            :         ovs_assert_failure(OVS_SOURCE_LOCATOR, __func__, #CONDITION);       \
<span class="lineNum">      53 </span>                :            :     }
<span class="lineNum">      54 </span>                :            : #else
<span class="lineNum">      55 </span>                :            : #define ovs_assert(CONDITION) ((void) (CONDITION))
<span class="lineNum">      56 </span>                :            : #endif
<span class="lineNum">      57 </span>                :            : OVS_NO_RETURN void ovs_assert_failure(const char *, const char *, const char *);
<span class="lineNum">      58 </span>                :            : 
<span class="lineNum">      59 </span>                :            : /* This is a void expression that issues a compiler error if POINTER cannot be
<span class="lineNum">      60 </span>                :            :  * compared for equality with the given pointer TYPE.  This generally means
<span class="lineNum">      61 </span>                :            :  * that POINTER is a qualified or unqualified TYPE.  However,
<span class="lineNum">      62 </span>                :            :  * BUILD_ASSERT_TYPE(POINTER, void *) will accept any pointer to object type,
<span class="lineNum">      63 </span>                :            :  * because any pointer to object can be compared for equality with &quot;void *&quot;.
<span class="lineNum">      64 </span>                :            :  *
<span class="lineNum">      65 </span>                :            :  * POINTER can be any expression.  The use of &quot;sizeof&quot; ensures that the
<span class="lineNum">      66 </span>                :            :  * expression is not actually evaluated, so that any side effects of the
<span class="lineNum">      67 </span>                :            :  * expression do not occur.
<span class="lineNum">      68 </span>                :            :  *
<span class="lineNum">      69 </span>                :            :  * The cast to int is present only to suppress an &quot;expression using sizeof
<span class="lineNum">      70 </span>                :            :  * bool&quot; warning from &quot;sparse&quot; (see
<span class="lineNum">      71 </span>                :            :  * http://permalink.gmane.org/gmane.comp.parsers.sparse/2967). */
<span class="lineNum">      72 </span>                :            : #define BUILD_ASSERT_TYPE(POINTER, TYPE) \
<span class="lineNum">      73 </span>                :            :     ((void) sizeof ((int) ((POINTER) == (TYPE) (POINTER))))
<span class="lineNum">      74 </span>                :            : 
<span class="lineNum">      75 </span>                :            : /* Casts 'pointer' to 'type' and issues a compiler warning if the cast changes
<span class="lineNum">      76 </span>                :            :  * anything other than an outermost &quot;const&quot; or &quot;volatile&quot; qualifier.
<span class="lineNum">      77 </span>                :            :  *
<span class="lineNum">      78 </span>                :            :  * The cast to int is present only to suppress an &quot;expression using sizeof
<span class="lineNum">      79 </span>                :            :  * bool&quot; warning from &quot;sparse&quot; (see
<span class="lineNum">      80 </span>                :            :  * http://permalink.gmane.org/gmane.comp.parsers.sparse/2967). */
<span class="lineNum">      81 </span>                :            : #define CONST_CAST(TYPE, POINTER)                               \
<span class="lineNum">      82 </span>                :            :     (BUILD_ASSERT_TYPE(POINTER, TYPE),                          \
<span class="lineNum">      83 </span>                :            :      (TYPE) (POINTER))
<span class="lineNum">      84 </span>                :            : 
<span class="lineNum">      85 </span>                :            : /* Given a pointer-typed lvalue OBJECT, expands to a pointer type that may be
<span class="lineNum">      86 </span>                :            :  * assigned to OBJECT. */
<span class="lineNum">      87 </span>                :            : #ifdef __GNUC__
<span class="lineNum">      88 </span>                :            : #define OVS_TYPEOF(OBJECT) typeof(OBJECT)
<span class="lineNum">      89 </span>                :            : #else
<span class="lineNum">      90 </span>                :            : #define OVS_TYPEOF(OBJECT) void *
<span class="lineNum">      91 </span>                :            : #endif
<span class="lineNum">      92 </span>                :            : 
<span class="lineNum">      93 </span>                :            : /* Given OBJECT of type pointer-to-structure, expands to the offset of MEMBER
<span class="lineNum">      94 </span>                :            :  * within an instance of the structure.
<span class="lineNum">      95 </span>                :            :  *
<span class="lineNum">      96 </span>                :            :  * The GCC-specific version avoids the technicality of undefined behavior if
<span class="lineNum">      97 </span>                :            :  * OBJECT is null, invalid, or not yet initialized.  This makes some static
<span class="lineNum">      98 </span>                :            :  * checkers (like Coverity) happier.  But the non-GCC version does not actually
<span class="lineNum">      99 </span>                :            :  * dereference any pointer, so it would be surprising for it to cause any
<span class="lineNum">     100 </span>                :            :  * problems in practice.
<span class="lineNum">     101 </span>                :            :  */
<span class="lineNum">     102 </span>                :            : #ifdef __GNUC__
<span class="lineNum">     103 </span>                :            : #define OBJECT_OFFSETOF(OBJECT, MEMBER) offsetof(typeof(*(OBJECT)), MEMBER)
<span class="lineNum">     104 </span>                :            : #else
<span class="lineNum">     105 </span>                :            : #define OBJECT_OFFSETOF(OBJECT, MEMBER) \
<span class="lineNum">     106 </span>                :            :     ((char *) &amp;(OBJECT)-&gt;MEMBER - (char *) (OBJECT))
<span class="lineNum">     107 </span>                :            : #endif
<span class="lineNum">     108 </span>                :            : 
<span class="lineNum">     109 </span>                :            : /* Yields the size of MEMBER within STRUCT. */
<span class="lineNum">     110 </span>                :            : #define MEMBER_SIZEOF(STRUCT, MEMBER) (sizeof(((STRUCT *) NULL)-&gt;MEMBER))
<span class="lineNum">     111 </span>                :            : 
<span class="lineNum">     112 </span>                :            : /* Yields the offset of the end of MEMBER within STRUCT. */
<span class="lineNum">     113 </span>                :            : #define OFFSETOFEND(STRUCT, MEMBER) \
<span class="lineNum">     114 </span>                :            :         (offsetof(STRUCT, MEMBER) + MEMBER_SIZEOF(STRUCT, MEMBER))
<span class="lineNum">     115 </span>                :            : 
<span class="lineNum">     116 </span>                :            : /* Given POINTER, the address of the given MEMBER in a STRUCT object, returns
<span class="lineNum">     117 </span>                :            :    the STRUCT object. */
<span class="lineNum">     118 </span>                :            : #define CONTAINER_OF(POINTER, STRUCT, MEMBER)                           \
<span class="lineNum">     119 </span>                :            :         ((STRUCT *) (void *) ((char *) (POINTER) - offsetof (STRUCT, MEMBER)))
<span class="lineNum">     120 </span>                :            : 
<span class="lineNum">     121 </span>                :            : /* Given POINTER, the address of the given MEMBER within an object of the type
<span class="lineNum">     122 </span>                :            :  * that that OBJECT points to, returns OBJECT as an assignment-compatible
<span class="lineNum">     123 </span>                :            :  * pointer type (either the correct pointer type or &quot;void *&quot;).  OBJECT must be
<span class="lineNum">     124 </span>                :            :  * an lvalue.
<span class="lineNum">     125 </span>                :            :  *
<span class="lineNum">     126 </span>                :            :  * This is the same as CONTAINER_OF except that it infers the structure type
<span class="lineNum">     127 </span>                :            :  * from the type of '*OBJECT'. */
<span class="lineNum">     128 </span>                :            : #define OBJECT_CONTAINING(POINTER, OBJECT, MEMBER)                      \
<span class="lineNum">     129 </span>                :            :     ((OVS_TYPEOF(OBJECT)) (void *)                                      \
<span class="lineNum">     130 </span>                :            :      ((char *) (POINTER) - OBJECT_OFFSETOF(OBJECT, MEMBER)))
<span class="lineNum">     131 </span>                :            : 
<span class="lineNum">     132 </span>                :            : /* Given POINTER, the address of the given MEMBER within an object of the type
<span class="lineNum">     133 </span>                :            :  * that that OBJECT points to, assigns the address of the outer object to
<span class="lineNum">     134 </span>                :            :  * OBJECT, which must be an lvalue.
<span class="lineNum">     135 </span>                :            :  *
<span class="lineNum">     136 </span>                :            :  * Evaluates to (void) 0 as the result is not to be used. */
<span class="lineNum">     137 </span>                :            : #define ASSIGN_CONTAINER(OBJECT, POINTER, MEMBER) \
<span class="lineNum">     138 </span>                :            :     ((OBJECT) = OBJECT_CONTAINING(POINTER, OBJECT, MEMBER), (void) 0)
<span class="lineNum">     139 </span>                :            : 
<span class="lineNum">     140 </span>                :            : /* As explained in the comment above OBJECT_OFFSETOF(), non-GNUC compilers
<span class="lineNum">     141 </span>                :            :  * like MSVC will complain about un-initialized variables if OBJECT
<span class="lineNum">     142 </span>                :            :  * hasn't already been initialized. To prevent such warnings, INIT_CONTAINER()
<span class="lineNum">     143 </span>                :            :  * can be used as a wrapper around ASSIGN_CONTAINER. */
<span class="lineNum">     144 </span>                :            : #define INIT_CONTAINER(OBJECT, POINTER, MEMBER) \
<span class="lineNum">     145 </span>                :            :     ((OBJECT) = NULL, ASSIGN_CONTAINER(OBJECT, POINTER, MEMBER))
<span class="lineNum">     146 </span>                :            : 
<span class="lineNum">     147 </span>                :            : /* Returns the number of elements in ARRAY. */
<span class="lineNum">     148 </span>                :            : #define ARRAY_SIZE(ARRAY) __ARRAY_SIZE(ARRAY)
<span class="lineNum">     149 </span>                :            : 
<span class="lineNum">     150 </span>                :            : /* Returns X / Y, rounding up.  X must be nonnegative to round correctly. */
<span class="lineNum">     151 </span>                :            : #define DIV_ROUND_UP(X, Y) (((X) + ((Y) - 1)) / (Y))
<span class="lineNum">     152 </span>                :            : 
<span class="lineNum">     153 </span>                :            : /* Returns X rounded up to the nearest multiple of Y. */
<span class="lineNum">     154 </span>                :            : #define ROUND_UP(X, Y) (DIV_ROUND_UP(X, Y) * (Y))
<span class="lineNum">     155 </span>                :            : 
<span class="lineNum">     156 </span>                :            : /* Returns the least number that, when added to X, yields a multiple of Y. */
<span class="lineNum">     157 </span>                :            : #define PAD_SIZE(X, Y) (ROUND_UP(X, Y) - (X))
<span class="lineNum">     158 </span>                :            : 
<span class="lineNum">     159 </span>                :            : /* Returns X rounded down to the nearest multiple of Y. */
<span class="lineNum">     160 </span>                :            : #define ROUND_DOWN(X, Y) ((X) / (Y) * (Y))
<span class="lineNum">     161 </span>                :            : 
<span class="lineNum">     162 </span>                :            : /* Returns true if X is a power of 2, otherwise false. */
<span class="lineNum">     163 </span>                :            : #define IS_POW2(X) ((X) &amp;&amp; !((X) &amp; ((X) - 1)))
<span class="lineNum">     164 </span>                :            : 
<span class="lineNum">     165 </span>                :            : /* Expands to an anonymous union that contains:
<span class="lineNum">     166 </span>                :            :  *
<span class="lineNum">     167 </span>                :            :  *    - MEMBERS in a nested anonymous struct.
<span class="lineNum">     168 </span>                :            :  *
<span class="lineNum">     169 </span>                :            :  *    - An array as large as MEMBERS plus padding to a multiple of UNIT bytes.
<span class="lineNum">     170 </span>                :            :  *
<span class="lineNum">     171 </span>                :            :  * The effect is to pad MEMBERS to a multiple of UNIT bytes.
<span class="lineNum">     172 </span>                :            :  *
<span class="lineNum">     173 </span>                :            :  * For example, the struct below is 8 bytes long, with 6 bytes of padding:
<span class="lineNum">     174 </span>                :            :  *
<span class="lineNum">     175 </span>                :            :  *     struct padded_struct {
<span class="lineNum">     176 </span>                :            :  *         PADDED_MEMBERS(8, uint8_t x; uint8_t y;);
<span class="lineNum">     177 </span>                :            :  *     };
<span class="lineNum">     178 </span>                :            :  */
<span class="lineNum">     179 </span>                :            : #define PADDED_MEMBERS(UNIT, MEMBERS)                               \
<span class="lineNum">     180 </span>                :            :     union {                                                         \
<span class="lineNum">     181 </span>                :            :         struct { MEMBERS };                                         \
<span class="lineNum">     182 </span>                :            :         uint8_t pad[ROUND_UP(sizeof(struct { MEMBERS }), UNIT)];    \
<span class="lineNum">     183 </span>                :            :     }
<a name="184"><span class="lineNum">     184 </span>                :            : </a>
<span class="lineNum">     185 </span>                :            : static inline bool
<span class="lineNum">     186 </span>                :<span class="lineCov">   10278113 : is_pow2(uintmax_t x)</span>
<span class="lineNum">     187 </span>                :            : {
<span class="lineNum">     188 </span>[<span class="branchCov" title="Branch 0 was taken 10278113 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>][<span class="branchCov" title="Branch 2 was taken 10270114 times"> + </span><span class="branchCov" title="Branch 3 was taken 7999 times"> + </span>]:<span class="lineCov">   10278113 :     return IS_POW2(x);</span>
<span class="lineNum">     189 </span>                :            : }
<span class="lineNum">     190 </span>                :            : 
<span class="lineNum">     191 </span>                :            : /* Returns X rounded up to a power of 2.  X must be a constant expression. */
<span class="lineNum">     192 </span>                :            : #define ROUND_UP_POW2(X) RUP2__(X)
<span class="lineNum">     193 </span>                :            : #define RUP2__(X) (RUP2_1(X) + 1)
<span class="lineNum">     194 </span>                :            : #define RUP2_1(X) (RUP2_2(X) | (RUP2_2(X) &gt;&gt; 16))
<span class="lineNum">     195 </span>                :            : #define RUP2_2(X) (RUP2_3(X) | (RUP2_3(X) &gt;&gt; 8))
<span class="lineNum">     196 </span>                :            : #define RUP2_3(X) (RUP2_4(X) | (RUP2_4(X) &gt;&gt; 4))
<span class="lineNum">     197 </span>                :            : #define RUP2_4(X) (RUP2_5(X) | (RUP2_5(X) &gt;&gt; 2))
<span class="lineNum">     198 </span>                :            : #define RUP2_5(X) (RUP2_6(X) | (RUP2_6(X) &gt;&gt; 1))
<span class="lineNum">     199 </span>                :            : #define RUP2_6(X) ((X) - 1)
<span class="lineNum">     200 </span>                :            : 
<span class="lineNum">     201 </span>                :            : /* Returns X rounded down to a power of 2.  X must be a constant expression. */
<span class="lineNum">     202 </span>                :            : #define ROUND_DOWN_POW2(X) RDP2__(X)
<span class="lineNum">     203 </span>                :            : #define RDP2__(X) (RDP2_1(X) - (RDP2_1(X) &gt;&gt; 1))
<span class="lineNum">     204 </span>                :            : #define RDP2_1(X) (RDP2_2(X) | (RDP2_2(X) &gt;&gt; 16))
<span class="lineNum">     205 </span>                :            : #define RDP2_2(X) (RDP2_3(X) | (RDP2_3(X) &gt;&gt; 8))
<span class="lineNum">     206 </span>                :            : #define RDP2_3(X) (RDP2_4(X) | (RDP2_4(X) &gt;&gt; 4))
<span class="lineNum">     207 </span>                :            : #define RDP2_4(X) (RDP2_5(X) | (RDP2_5(X) &gt;&gt; 2))
<span class="lineNum">     208 </span>                :            : #define RDP2_5(X) (      (X) | (      (X) &gt;&gt; 1))
<span class="lineNum">     209 </span>                :            : 
<span class="lineNum">     210 </span>                :            : /* Macros for sizing bitmaps */
<span class="lineNum">     211 </span>                :            : #define BITMAP_ULONG_BITS (sizeof(unsigned long) * CHAR_BIT)
<span class="lineNum">     212 </span>                :            : #define BITMAP_N_LONGS(N_BITS) DIV_ROUND_UP(N_BITS, BITMAP_ULONG_BITS)
<span class="lineNum">     213 </span>                :            : 
<span class="lineNum">     214 </span>                :            : /* Given ATTR, and TYPE, cast the ATTR to TYPE by first casting ATTR to
<span class="lineNum">     215 </span>                :            :  * (void *). This is to suppress the alignment warning issued by clang. */
<span class="lineNum">     216 </span>                :            : #define ALIGNED_CAST(TYPE, ATTR) ((TYPE) (void *) (ATTR))
<span class="lineNum">     217 </span>                :            : 
<span class="lineNum">     218 </span>                :            : #ifdef __cplusplus
<span class="lineNum">     219 </span>                :            : }
<span class="lineNum">     220 </span>                :            : #endif
<span class="lineNum">     221 </span>                :            : 
<span class="lineNum">     222 </span>                :            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
